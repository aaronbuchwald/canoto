// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto v0.13.1
// source: canoto.go

package examples

import (
	"io"
	"reflect"
	"slices"
	"sync/atomic"
	"unicode/utf8"

	"github.com/StephenButtolph/canoto"
)

// Ensure that unused imports do not error
var (
	_ atomic.Int64

	_ = slices.Index[[]reflect.Type, reflect.Type]
	_ = io.ErrUnexpectedEOF
	_ = utf8.ValidString
)

const (
	canoto__LargestFieldNumber__Uint__tag = "\xf8\xff\xff\xff\x0f" // canoto.Tag(536870911, canoto.Varint)
)

type canotoData_LargestFieldNumber struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*LargestFieldNumber[T1]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(LargestFieldNumber[T1]{}))
	var zero LargestFieldNumber[T1]
	s := &canoto.Spec{
		Name: "LargestFieldNumber",
		Fields: []*canoto.FieldType{
			{
				FieldNumber: 536870911,
				Name:        "Uint",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*LargestFieldNumber[T1]) MakeCanoto() *LargestFieldNumber[T1] {
	return new(LargestFieldNumber[T1])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *LargestFieldNumber[T1]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *LargestFieldNumber[T1]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = LargestFieldNumber[T1]{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 536870911:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *LargestFieldNumber[T1]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *LargestFieldNumber[T1]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	if !canoto.IsZero(c.Uint) {
		size += len(canoto__LargestFieldNumber__Uint__tag) + canoto.SizeUint(c.Uint)
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *LargestFieldNumber[T1]) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *LargestFieldNumber[T1]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *LargestFieldNumber[T1]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Uint) {
		canoto.Append(&w, canoto__LargestFieldNumber__Uint__tag)
		canoto.AppendUint(&w, c.Uint)
	}
	return w
}

const (
	canoto__OneOf__A1__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__OneOf__B1__tag = "\x18" // canoto.Tag(3, canoto.Varint)
	canoto__OneOf__B2__tag = "\x20" // canoto.Tag(4, canoto.Varint)
	canoto__OneOf__C__tag  = "\x28" // canoto.Tag(5, canoto.Varint)
	canoto__OneOf__D__tag  = "\x30" // canoto.Tag(6, canoto.Varint)
	canoto__OneOf__A2__tag = "\x38" // canoto.Tag(7, canoto.Varint)
)

type canotoData_OneOf struct {
	size atomic.Int64

	AOneOf atomic.Uint32
	BOneOf atomic.Uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*OneOf) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(OneOf{}))
	var zero OneOf
	s := &canoto.Spec{
		Name: "OneOf",
		Fields: []*canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "A1",
				OneOf:       "A",
				TypeInt:    canoto.SizeOf(zero.A1),
			},
			{
				FieldNumber: 3,
				Name:        "B1",
				OneOf:       "B",
				TypeInt:    canoto.SizeOf(zero.B1),
			},
			{
				FieldNumber: 4,
				Name:        "B2",
				OneOf:       "B",
				TypeInt:    canoto.SizeOf(zero.B2),
			},
			{
				FieldNumber: 5,
				Name:        "C",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.C),
			},
			{
				FieldNumber: 6,
				Name:        "D",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.D),
			},
			{
				FieldNumber: 7,
				Name:        "A2",
				OneOf:       "A",
				TypeInt:    canoto.SizeOf(zero.A2),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*OneOf) MakeCanoto() *OneOf {
	return new(OneOf)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *OneOf) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *OneOf) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = OneOf{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.AOneOf.Swap(1) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A1); err != nil {
				return err
			}
			if canoto.IsZero(c.A1) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.BOneOf.Swap(3) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B1); err != nil {
				return err
			}
			if canoto.IsZero(c.B1) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.BOneOf.Swap(4) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.B2); err != nil {
				return err
			}
			if canoto.IsZero(c.B2) {
				return canoto.ErrZeroValue
			}
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.D); err != nil {
				return err
			}
			if canoto.IsZero(c.D) {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.AOneOf.Swap(7) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			if err := canoto.ReadInt(&r, &c.A2); err != nil {
				return err
			}
			if canoto.IsZero(c.A2) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *OneOf) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var (
		AOneOf uint32
		BOneOf uint32
	)
	if !canoto.IsZero(c.A1) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 4
	}
	if !canoto.IsZero(c.A2) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 7
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *OneOf) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size   int
		AOneOf uint32
		BOneOf uint32
	)
	if !canoto.IsZero(c.A1) {
		size += len(canoto__OneOf__A1__tag) + canoto.SizeInt(c.A1)
		AOneOf = 1
	}
	if !canoto.IsZero(c.B1) {
		size += len(canoto__OneOf__B1__tag) + canoto.SizeInt(c.B1)
		BOneOf = 3
	}
	if !canoto.IsZero(c.B2) {
		size += len(canoto__OneOf__B2__tag) + canoto.SizeInt(c.B2)
		BOneOf = 4
	}
	if !canoto.IsZero(c.C) {
		size += len(canoto__OneOf__C__tag) + canoto.SizeInt(c.C)
	}
	if !canoto.IsZero(c.D) {
		size += len(canoto__OneOf__D__tag) + canoto.SizeInt(c.D)
	}
	if !canoto.IsZero(c.A2) {
		size += len(canoto__OneOf__A2__tag) + canoto.SizeInt(c.A2)
		AOneOf = 7
	}
	c.canotoData.size.Store(int64(size))
	c.canotoData.AOneOf.Store(AOneOf)
	c.canotoData.BOneOf.Store(BOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *OneOf) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// CachedWhichOneOfA returns the previously calculated field number used
// to represent A.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfA() uint32 {
	return c.canotoData.AOneOf.Load()
}

// CachedWhichOneOfB returns the previously calculated field number used
// to represent B.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfB() uint32 {
	return c.canotoData.BOneOf.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *OneOf) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *OneOf) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.A1) {
		canoto.Append(&w, canoto__OneOf__A1__tag)
		canoto.AppendInt(&w, c.A1)
	}
	if !canoto.IsZero(c.B1) {
		canoto.Append(&w, canoto__OneOf__B1__tag)
		canoto.AppendInt(&w, c.B1)
	}
	if !canoto.IsZero(c.B2) {
		canoto.Append(&w, canoto__OneOf__B2__tag)
		canoto.AppendInt(&w, c.B2)
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__OneOf__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	if !canoto.IsZero(c.D) {
		canoto.Append(&w, canoto__OneOf__D__tag)
		canoto.AppendInt(&w, c.D)
	}
	if !canoto.IsZero(c.A2) {
		canoto.Append(&w, canoto__OneOf__A2__tag)
		canoto.AppendInt(&w, c.A2)
	}
	return w
}

const (
	canoto__Node__Value__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__Node__Next__tag  = "\x12" // canoto.Tag(2, canoto.Len)
)

type canotoData_Node struct {
	size atomic.Int64

	OneOfOneOf atomic.Uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*Node) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Node{}))
	var zero Node
	s := &canoto.Spec{
		Name: "Node",
		Fields: []*canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "Value",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.Value),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ 2,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "OneOf",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Node) MakeCanoto() *Node {
	return new(Node)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Node) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Node) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Node{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Value); err != nil {
				return err
			}
			if canoto.IsZero(c.Value) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}
			if c.canotoData.OneOfOneOf.Swap(2) != 0 {
				return canoto.ErrDuplicateOneOf
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Node) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var (
		OneOfOneOf uint32
	)
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if (c.Next).CachedCanotoSize() != 0 {
			if OneOfOneOf != 0 {
				return false
			}
			OneOfOneOf = 2
		}
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *Node) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size       int
		OneOfOneOf uint32
	)
	if !canoto.IsZero(c.Value) {
		size += len(canoto__Node__Value__tag) + canoto.SizeInt(c.Value)
	}
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__Node__Next__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
			OneOfOneOf = 2
		}
	}
	c.canotoData.size.Store(int64(size))
	c.canotoData.OneOfOneOf.Store(OneOfOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Node) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// CachedWhichOneOfOneOf returns the previously calculated field number used
// to represent OneOf.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *Node) CachedWhichOneOfOneOf() uint32 {
	return c.canotoData.OneOfOneOf.Load()
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Node) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Node) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Value) {
		canoto.Append(&w, canoto__Node__Value__tag)
		canoto.AppendInt(&w, c.Value)
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Node__Next__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__RecursiveA__Next__tag = "\x0a" // canoto.Tag(1, canoto.Len)
)

type canotoData_RecursiveA struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*RecursiveA) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(RecursiveA{}))
	var zero RecursiveA
	s := &canoto.Spec{
		Name: "RecursiveA",
		Fields: []*canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*RecursiveA) MakeCanoto() *RecursiveA {
	return new(RecursiveA)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *RecursiveA) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *RecursiveA) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = RecursiveA{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *RecursiveA) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *RecursiveA) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__RecursiveA__Next__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *RecursiveA) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveA) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveA) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__RecursiveA__Next__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__RecursiveB__Next__tag = "\x0a" // canoto.Tag(1, canoto.Len)
)

type canotoData_RecursiveB struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*RecursiveB) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(RecursiveB{}))
	var zero RecursiveB
	s := &canoto.Spec{
		Name: "RecursiveB",
		Fields: []*canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Next),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Next",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*RecursiveB) MakeCanoto() *RecursiveB {
	return new(RecursiveB)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *RecursiveB) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *RecursiveB) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = RecursiveB{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Next = canoto.MakePointer(c.Next)
			if err := (c.Next).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *RecursiveB) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if c.Next != nil && !(c.Next).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *RecursiveB) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	if c.Next != nil {
		(c.Next).CalculateCanotoCache()
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__RecursiveB__Next__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *RecursiveB) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveB) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *RecursiveB) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if c.Next != nil {
		if fieldSize := (c.Next).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__RecursiveB__Next__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = (c.Next).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__GenericField__Value__tag                = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__GenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__GenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__GenericField__Pointer__tag              = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__GenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__GenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(6, canoto.Len)
	canoto__GenericField__Field__tag                = "\x3a" // canoto.Tag(7, canoto.Len)
	canoto__GenericField__RepeatedField__tag        = "\x42" // canoto.Tag(8, canoto.Len)
	canoto__GenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(9, canoto.Len)
)

type canotoData_GenericField struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*GenericField[T1, T2, T3]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(GenericField[T1, T2, T3]{}))
	var zero GenericField[T1, T2, T3]
	s := &canoto.Spec{
		Name: "GenericField",
		Fields: []*canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(&zero.Value),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Value",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntryPointer(zero.RepeatedValue)),
				/*FieldNumber:   */ 2,
				/*Name:          */ "RepeatedValue",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntryPointer(zero.FixedRepeatedValue[:])),
				/*FieldNumber:   */ 3,
				/*Name:          */ "FixedRepeatedValue",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedValue)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(zero.Pointer),
				/*FieldNumber:   */ 4,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ 5,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ T2(canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ 6,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 7,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ 8,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ 9,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*GenericField[T1, T2, T3]) MakeCanoto() *GenericField[T1, T2, T3] {
	return new(GenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *GenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *GenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = GenericField[T1, T2, T3]{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := T2(&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.RepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__GenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.RepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedValue) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := T2(&c.FixedRepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := T2(c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[0] = canoto.MakePointer(c.RepeatedPointer[0])
				if err := T2(c.RepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__GenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[1+i] = canoto.MakePointer(c.RepeatedPointer[1+i])
				if err := T2(c.RepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := T2(c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedPointer) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[1+i] = canoto.MakePointer(c.FixedRepeatedPointer[1+i])
				if err := T2(c.FixedRepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__GenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[0] = c.RepeatedField[0].MakeCanoto()
				if err := c.RepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__GenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[1+i] = c.RepeatedField[1+i].MakeCanoto()
				if err := c.RepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 9:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedField) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__GenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__GenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[1+i] = c.FixedRepeatedField[1+i].MakeCanoto()
				if err := c.FixedRepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *GenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !T2(&c.Value).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedValue {
		if !T2(&c.RepeatedValue[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !T2(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !T2(c.Pointer).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedPointer {
		if c.RepeatedPointer[i] != nil && !T2(c.RepeatedPointer[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !T2((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	for i := range c.RepeatedField {
		if !c.RepeatedField[i].ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *GenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	T2(&c.Value).CalculateCanotoCache()
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__GenericField__Value__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedValue {
		T2(&c.RepeatedValue[i]).CalculateCanotoCache()
		fieldSize := T2(&c.RepeatedValue[i]).CachedCanotoSize()
		size += len(canoto__GenericField__RepeatedValue__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedValue {
			T2(&c.FixedRepeatedValue[i]).CalculateCanotoCache()
			fieldSize := T2(&c.FixedRepeatedValue[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__GenericField__FixedRepeatedValue__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if c.Pointer != nil {
		T2(c.Pointer).CalculateCanotoCache()
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__GenericField__Pointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
	}
	for i := range c.RepeatedPointer {
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			T2(c.RepeatedPointer[i]).CalculateCanotoCache()
			fieldSize = T2(c.RepeatedPointer[i]).CachedCanotoSize()
		}
		size += len(canoto__GenericField__RepeatedPointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedPointer {
			var fieldSize int
			if c.FixedRepeatedPointer[i] != nil {
				T2(c.FixedRepeatedPointer[i]).CalculateCanotoCache()
				fieldSize = T2(c.FixedRepeatedPointer[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += len(canoto__GenericField__FixedRepeatedPointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__GenericField__Field__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedField {
		c.RepeatedField[i].CalculateCanotoCache()
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		size += len(canoto__GenericField__RepeatedField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedField {
			c.FixedRepeatedField[i].CalculateCanotoCache()
			fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__GenericField__FixedRepeatedField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *GenericField[T1, T2, T3]) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *GenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *GenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := T2(&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Value__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = T2(&c.Value).MarshalCanotoInto(w)
	}
	for i := range c.RepeatedValue {
		canoto.Append(&w, canoto__GenericField__RepeatedValue__tag)
		canoto.AppendUint(&w, uint64(T2(&c.RepeatedValue[i]).CachedCanotoSize()))
		w = T2(&c.RepeatedValue[i]).MarshalCanotoInto(w)
	}
	{
		isZero := true
		for i := range c.FixedRepeatedValue {
			if T2(&c.FixedRepeatedValue[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedValue {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedValue__tag)
				canoto.AppendUint(&w, uint64(T2(&c.FixedRepeatedValue[i]).CachedCanotoSize()))
				w = T2(&c.FixedRepeatedValue[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := T2(c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__GenericField__Pointer__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = T2(c.Pointer).MarshalCanotoInto(w)
		}
	}
	for i := range c.RepeatedPointer {
		canoto.Append(&w, canoto__GenericField__RepeatedPointer__tag)
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			fieldSize = T2(c.RepeatedPointer[i]).CachedCanotoSize()
		}
		canoto.AppendUint(&w, uint64(fieldSize))
		if fieldSize != 0 {
			w = T2(c.RepeatedPointer[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedPointer {
			if c.FixedRepeatedPointer[i] != nil && T2(c.FixedRepeatedPointer[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedPointer {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedPointer__tag)
				var fieldSize int
				if c.FixedRepeatedPointer[i] != nil {
					fieldSize = T2(c.FixedRepeatedPointer[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, uint64(fieldSize))
				if fieldSize != 0 {
					w = T2(c.FixedRepeatedPointer[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__GenericField__Field__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = c.Field.MarshalCanotoInto(w)
	}
	for i := range c.RepeatedField {
		canoto.Append(&w, canoto__GenericField__RepeatedField__tag)
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		canoto.AppendUint(&w, uint64(fieldSize))
		if fieldSize != 0 {
			w = c.RepeatedField[i].MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedField {
			if c.FixedRepeatedField[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedField {
				canoto.Append(&w, canoto__GenericField__FixedRepeatedField__tag)
				fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
				canoto.AppendUint(&w, uint64(fieldSize))
				if fieldSize != 0 {
					w = c.FixedRepeatedField[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__NestedGenericField__Value__tag                = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__NestedGenericField__RepeatedValue__tag        = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedValue__tag   = "\x1a" // canoto.Tag(3, canoto.Len)
	canoto__NestedGenericField__Pointer__tag              = "\x22" // canoto.Tag(4, canoto.Len)
	canoto__NestedGenericField__RepeatedPointer__tag      = "\x2a" // canoto.Tag(5, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedPointer__tag = "\x32" // canoto.Tag(6, canoto.Len)
	canoto__NestedGenericField__Field__tag                = "\x3a" // canoto.Tag(7, canoto.Len)
	canoto__NestedGenericField__RepeatedField__tag        = "\x42" // canoto.Tag(8, canoto.Len)
	canoto__NestedGenericField__FixedRepeatedField__tag   = "\x4a" // canoto.Tag(9, canoto.Len)
)

type canotoData_NestedGenericField struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*NestedGenericField[T1, T2, T3]) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(NestedGenericField[T1, T2, T3]{}))
	var zero NestedGenericField[T1, T2, T3]
	s := &canoto.Spec{
		Name: "NestedGenericField",
		Fields: []*canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.Value),
				/*FieldNumber:   */ 1,
				/*Name:          */ "Value",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryPointer(zero.RepeatedValue)),
				/*FieldNumber:   */ 2,
				/*Name:          */ "RepeatedValue",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryPointer(zero.FixedRepeatedValue[:])),
				/*FieldNumber:   */ 3,
				/*Name:          */ "FixedRepeatedValue",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedValue)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ 4,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ 5,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ 6,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 7,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ 8,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ 9,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*NestedGenericField[T1, T2, T3]) MakeCanoto() *NestedGenericField[T1, T2, T3] {
	return new(NestedGenericField[T1, T2, T3])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *NestedGenericField[T1, T2, T3]) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = NestedGenericField[T1, T2, T3]{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.Value).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedValue__tag)
			if err != nil {
				return err
			}

			c.RepeatedValue = canoto.MakeSlice(c.RepeatedValue, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedValue[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedValue) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedValue__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedValue__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedValue[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 5:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[0] = canoto.MakePointer(c.RepeatedPointer[0])
				if err := (c.RepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[1+i] = canoto.MakePointer(c.RepeatedPointer[1+i])
				if err := (c.RepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 6:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedPointer) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[1+i] = canoto.MakePointer(c.FixedRepeatedPointer[1+i])
				if err := (c.FixedRepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 8:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__NestedGenericField__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[0] = c.RepeatedField[0].MakeCanoto()
				if err := c.RepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__NestedGenericField__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[1+i] = c.RepeatedField[1+i].MakeCanoto()
				if err := c.RepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 9:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedField) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__NestedGenericField__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__NestedGenericField__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[1+i] = c.FixedRepeatedField[1+i].MakeCanoto()
				if err := c.FixedRepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.Value).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedValue {
		if !(&c.RepeatedValue[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedValue {
		if !(&(&c.FixedRepeatedValue)[i]).ValidCanoto() {
			return false
		}
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedPointer {
		if c.RepeatedPointer[i] != nil && !(c.RepeatedPointer[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	for i := range c.RepeatedField {
		if !c.RepeatedField[i].ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *NestedGenericField[T1, T2, T3]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	(&c.Value).CalculateCanotoCache()
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__NestedGenericField__Value__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedValue {
		(&c.RepeatedValue[i]).CalculateCanotoCache()
		fieldSize := (&c.RepeatedValue[i]).CachedCanotoSize()
		size += len(canoto__NestedGenericField__RepeatedValue__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedValue {
			(&c.FixedRepeatedValue[i]).CalculateCanotoCache()
			fieldSize := (&c.FixedRepeatedValue[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__NestedGenericField__FixedRepeatedValue__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__NestedGenericField__Pointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
	}
	for i := range c.RepeatedPointer {
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			(c.RepeatedPointer[i]).CalculateCanotoCache()
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		size += len(canoto__NestedGenericField__RepeatedPointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedPointer {
			var fieldSize int
			if c.FixedRepeatedPointer[i] != nil {
				(c.FixedRepeatedPointer[i]).CalculateCanotoCache()
				fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += len(canoto__NestedGenericField__FixedRepeatedPointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__NestedGenericField__Field__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedField {
		c.RepeatedField[i].CalculateCanotoCache()
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		size += len(canoto__NestedGenericField__RepeatedField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedField {
			c.FixedRepeatedField[i].CalculateCanotoCache()
			fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__NestedGenericField__FixedRepeatedField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *NestedGenericField[T1, T2, T3]) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *NestedGenericField[T1, T2, T3]) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.Value).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Value__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = (&c.Value).MarshalCanotoInto(w)
	}
	for i := range c.RepeatedValue {
		canoto.Append(&w, canoto__NestedGenericField__RepeatedValue__tag)
		canoto.AppendUint(&w, uint64((&c.RepeatedValue[i]).CachedCanotoSize()))
		w = (&c.RepeatedValue[i]).MarshalCanotoInto(w)
	}
	{
		isZero := true
		for i := range c.FixedRepeatedValue {
			if (&c.FixedRepeatedValue[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedValue {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedValue__tag)
				canoto.AppendUint(&w, uint64((&c.FixedRepeatedValue[i]).CachedCanotoSize()))
				w = (&c.FixedRepeatedValue[i]).MarshalCanotoInto(w)
			}
		}
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__NestedGenericField__Pointer__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	for i := range c.RepeatedPointer {
		canoto.Append(&w, canoto__NestedGenericField__RepeatedPointer__tag)
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		canoto.AppendUint(&w, uint64(fieldSize))
		if fieldSize != 0 {
			w = (c.RepeatedPointer[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedPointer {
			if c.FixedRepeatedPointer[i] != nil && (c.FixedRepeatedPointer[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedPointer {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedPointer__tag)
				var fieldSize int
				if c.FixedRepeatedPointer[i] != nil {
					fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, uint64(fieldSize))
				if fieldSize != 0 {
					w = (c.FixedRepeatedPointer[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__NestedGenericField__Field__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = c.Field.MarshalCanotoInto(w)
	}
	for i := range c.RepeatedField {
		canoto.Append(&w, canoto__NestedGenericField__RepeatedField__tag)
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		canoto.AppendUint(&w, uint64(fieldSize))
		if fieldSize != 0 {
			w = c.RepeatedField[i].MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedField {
			if c.FixedRepeatedField[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedField {
				canoto.Append(&w, canoto__NestedGenericField__FixedRepeatedField__tag)
				fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
				canoto.AppendUint(&w, uint64(fieldSize))
				if fieldSize != 0 {
					w = c.FixedRepeatedField[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}

const (
	canoto__Embedded__OneOf__tag              = "\x0a" // canoto.Tag(1, canoto.Len)
	canoto__Embedded__LargestFieldNumber__tag = "\x12" // canoto.Tag(2, canoto.Len)
	canoto__Embedded__GenericField__tag       = "\x1a" // canoto.Tag(3, canoto.Len)
)

type canotoData_Embedded struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*Embedded) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Embedded{}))
	var zero Embedded
	s := &canoto.Spec{
		Name: "Embedded",
		Fields: []*canoto.FieldType{
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.OneOf),
				/*FieldNumber:   */ 1,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.LargestFieldNumber),
				/*FieldNumber:   */ 2,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.GenericField,
				/*FieldNumber:   */ 3,
				/*Name:          */ "GenericField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Embedded) MakeCanoto() *Embedded {
	return new(Embedded)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Embedded) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Embedded) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Embedded{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 2:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.LargestFieldNumber = canoto.MakePointer(c.LargestFieldNumber)
			if err := (c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 3:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.GenericField = c.GenericField.MakeCanoto()
			if err := c.GenericField.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Embedded) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.LargestFieldNumber != nil && !(c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	if !c.GenericField.ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *Embedded) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__Embedded__OneOf__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if c.LargestFieldNumber != nil {
		(c.LargestFieldNumber).CalculateCanotoCache()
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__Embedded__LargestFieldNumber__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
	}
	c.GenericField.CalculateCanotoCache()
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__Embedded__GenericField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Embedded) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Embedded) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Embedded) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__OneOf__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.LargestFieldNumber != nil {
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Embedded__LargestFieldNumber__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = (c.LargestFieldNumber).MarshalCanotoInto(w)
		}
	}
	if fieldSize := c.GenericField.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Embedded__GenericField__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = c.GenericField.MarshalCanotoInto(w)
	}
	return w
}

const (
	canoto__A__B_1_1C__tag = "\x08" // canoto.Tag(1, canoto.Varint)
)

type canotoData_A struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*A) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(A{}))
	var zero A
	s := &canoto.Spec{
		Name: "A",
		Fields: []*canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "B__C",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.B__C),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*A) MakeCanoto() *A {
	return new(A)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.B__C); err != nil {
				return err
			}
			if canoto.IsZero(c.B__C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *A) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	if !canoto.IsZero(c.B__C) {
		size += len(canoto__A__B_1_1C__tag) + canoto.SizeInt(c.B__C)
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.B__C) {
		canoto.Append(&w, canoto__A__B_1_1C__tag)
		canoto.AppendInt(&w, c.B__C)
	}
	return w
}

const (
	canoto__A_1_1B__C__tag = "\x08" // canoto.Tag(1, canoto.Varint)
)

type canotoData_A__B struct {
	size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*A__B) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(A__B{}))
	var zero A__B
	s := &canoto.Spec{
		Name: "A__B",
		Fields: []*canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "C",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.C),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*A__B) MakeCanoto() *A__B {
	return new(A__B)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *A__B) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *A__B) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = A__B{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.C); err != nil {
				return err
			}
			if canoto.IsZero(c.C) {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *A__B) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *A__B) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	if !canoto.IsZero(c.C) {
		size += len(canoto__A_1_1B__C__tag) + canoto.SizeInt(c.C)
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *A__B) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A__B) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *A__B) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.C) {
		canoto.Append(&w, canoto__A_1_1B__C__tag)
		canoto.AppendInt(&w, c.C)
	}
	return w
}

const (
	canoto__Scalars__Int8__tag                            = "\x08"     // canoto.Tag(1, canoto.Varint)
	canoto__Scalars__Int16__tag                           = "\x10"     // canoto.Tag(2, canoto.Varint)
	canoto__Scalars__Int32__tag                           = "\x18"     // canoto.Tag(3, canoto.Varint)
	canoto__Scalars__Int64__tag                           = "\x20"     // canoto.Tag(4, canoto.Varint)
	canoto__Scalars__Uint8__tag                           = "\x28"     // canoto.Tag(5, canoto.Varint)
	canoto__Scalars__Uint16__tag                          = "\x30"     // canoto.Tag(6, canoto.Varint)
	canoto__Scalars__Uint32__tag                          = "\x38"     // canoto.Tag(7, canoto.Varint)
	canoto__Scalars__Uint64__tag                          = "\x40"     // canoto.Tag(8, canoto.Varint)
	canoto__Scalars__Sfixed32__tag                        = "\x4d"     // canoto.Tag(9, canoto.I32)
	canoto__Scalars__Fixed32__tag                         = "\x55"     // canoto.Tag(10, canoto.I32)
	canoto__Scalars__Sfixed64__tag                        = "\x59"     // canoto.Tag(11, canoto.I64)
	canoto__Scalars__Fixed64__tag                         = "\x61"     // canoto.Tag(12, canoto.I64)
	canoto__Scalars__Bool__tag                            = "\x68"     // canoto.Tag(13, canoto.Varint)
	canoto__Scalars__String__tag                          = "\x72"     // canoto.Tag(14, canoto.Len)
	canoto__Scalars__Bytes__tag                           = "\x7a"     // canoto.Tag(15, canoto.Len)
	canoto__Scalars__LargestFieldNumber__tag              = "\x82\x01" // canoto.Tag(16, canoto.Len)
	canoto__Scalars__RepeatedInt8__tag                    = "\x8a\x01" // canoto.Tag(17, canoto.Len)
	canoto__Scalars__RepeatedInt16__tag                   = "\x92\x01" // canoto.Tag(18, canoto.Len)
	canoto__Scalars__RepeatedInt32__tag                   = "\x9a\x01" // canoto.Tag(19, canoto.Len)
	canoto__Scalars__RepeatedInt64__tag                   = "\xa2\x01" // canoto.Tag(20, canoto.Len)
	canoto__Scalars__RepeatedUint8__tag                   = "\xaa\x01" // canoto.Tag(21, canoto.Len)
	canoto__Scalars__RepeatedUint16__tag                  = "\xb2\x01" // canoto.Tag(22, canoto.Len)
	canoto__Scalars__RepeatedUint32__tag                  = "\xba\x01" // canoto.Tag(23, canoto.Len)
	canoto__Scalars__RepeatedUint64__tag                  = "\xc2\x01" // canoto.Tag(24, canoto.Len)
	canoto__Scalars__RepeatedSfixed32__tag                = "\xca\x01" // canoto.Tag(25, canoto.Len)
	canoto__Scalars__RepeatedFixed32__tag                 = "\xd2\x01" // canoto.Tag(26, canoto.Len)
	canoto__Scalars__RepeatedSfixed64__tag                = "\xda\x01" // canoto.Tag(27, canoto.Len)
	canoto__Scalars__RepeatedFixed64__tag                 = "\xe2\x01" // canoto.Tag(28, canoto.Len)
	canoto__Scalars__RepeatedBool__tag                    = "\xea\x01" // canoto.Tag(29, canoto.Len)
	canoto__Scalars__RepeatedString__tag                  = "\xf2\x01" // canoto.Tag(30, canoto.Len)
	canoto__Scalars__RepeatedBytes__tag                   = "\xfa\x01" // canoto.Tag(31, canoto.Len)
	canoto__Scalars__RepeatedLargestFieldNumber__tag      = "\x82\x02" // canoto.Tag(32, canoto.Len)
	canoto__Scalars__FixedRepeatedInt8__tag               = "\x8a\x02" // canoto.Tag(33, canoto.Len)
	canoto__Scalars__FixedRepeatedInt16__tag              = "\x92\x02" // canoto.Tag(34, canoto.Len)
	canoto__Scalars__FixedRepeatedInt32__tag              = "\x9a\x02" // canoto.Tag(35, canoto.Len)
	canoto__Scalars__FixedRepeatedInt64__tag              = "\xa2\x02" // canoto.Tag(36, canoto.Len)
	canoto__Scalars__FixedRepeatedUint8__tag              = "\xaa\x02" // canoto.Tag(37, canoto.Len)
	canoto__Scalars__FixedRepeatedUint16__tag             = "\xb2\x02" // canoto.Tag(38, canoto.Len)
	canoto__Scalars__FixedRepeatedUint32__tag             = "\xba\x02" // canoto.Tag(39, canoto.Len)
	canoto__Scalars__FixedRepeatedUint64__tag             = "\xc2\x02" // canoto.Tag(40, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed32__tag           = "\xca\x02" // canoto.Tag(41, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed32__tag            = "\xd2\x02" // canoto.Tag(42, canoto.Len)
	canoto__Scalars__FixedRepeatedSfixed64__tag           = "\xda\x02" // canoto.Tag(43, canoto.Len)
	canoto__Scalars__FixedRepeatedFixed64__tag            = "\xe2\x02" // canoto.Tag(44, canoto.Len)
	canoto__Scalars__FixedRepeatedBool__tag               = "\xea\x02" // canoto.Tag(45, canoto.Len)
	canoto__Scalars__FixedRepeatedString__tag             = "\xf2\x02" // canoto.Tag(46, canoto.Len)
	canoto__Scalars__FixedBytes__tag                      = "\xfa\x02" // canoto.Tag(47, canoto.Len)
	canoto__Scalars__RepeatedFixedBytes__tag              = "\x82\x03" // canoto.Tag(48, canoto.Len)
	canoto__Scalars__FixedRepeatedBytes__tag              = "\x8a\x03" // canoto.Tag(49, canoto.Len)
	canoto__Scalars__FixedRepeatedFixedBytes__tag         = "\x92\x03" // canoto.Tag(50, canoto.Len)
	canoto__Scalars__FixedRepeatedLargestFieldNumber__tag = "\x9a\x03" // canoto.Tag(51, canoto.Len)
	canoto__Scalars__ConstRepeatedUint64__tag             = "\xa2\x03" // canoto.Tag(52, canoto.Len)
	canoto__Scalars__CustomType__tag                      = "\xaa\x03" // canoto.Tag(53, canoto.Len)
	canoto__Scalars__CustomUint32__tag                    = "\xb5\x03" // canoto.Tag(54, canoto.I32)
	canoto__Scalars__CustomString__tag                    = "\xba\x03" // canoto.Tag(55, canoto.Len)
	canoto__Scalars__CustomBytes__tag                     = "\xc2\x03" // canoto.Tag(56, canoto.Len)
	canoto__Scalars__CustomFixedBytes__tag                = "\xca\x03" // canoto.Tag(57, canoto.Len)
	canoto__Scalars__CustomRepeatedBytes__tag             = "\xd2\x03" // canoto.Tag(58, canoto.Len)
	canoto__Scalars__CustomRepeatedFixedBytes__tag        = "\xda\x03" // canoto.Tag(59, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedBytes__tag        = "\xe2\x03" // canoto.Tag(60, canoto.Len)
	canoto__Scalars__CustomFixedRepeatedFixedBytes__tag   = "\xea\x03" // canoto.Tag(61, canoto.Len)
	canoto__Scalars__OneOf__tag                           = "\xf2\x03" // canoto.Tag(62, canoto.Len)
	canoto__Scalars__Pointer__tag                         = "\xfa\x03" // canoto.Tag(63, canoto.Len)
	canoto__Scalars__RepeatedPointer__tag                 = "\x82\x04" // canoto.Tag(64, canoto.Len)
	canoto__Scalars__FixedRepeatedPointer__tag            = "\x8a\x04" // canoto.Tag(65, canoto.Len)
	canoto__Scalars__Field__tag                           = "\x92\x04" // canoto.Tag(66, canoto.Len)
	canoto__Scalars__RepeatedField__tag                   = "\x9a\x04" // canoto.Tag(67, canoto.Len)
	canoto__Scalars__FixedRepeatedField__tag              = "\xa2\x04" // canoto.Tag(68, canoto.Len)
)

type canotoData_Scalars struct {
	size                    atomic.Int64
	RepeatedInt8Size        atomic.Int64
	RepeatedInt16Size       atomic.Int64
	RepeatedInt32Size       atomic.Int64
	RepeatedInt64Size       atomic.Int64
	RepeatedUint8Size       atomic.Int64
	RepeatedUint16Size      atomic.Int64
	RepeatedUint32Size      atomic.Int64
	RepeatedUint64Size      atomic.Int64
	FixedRepeatedInt8Size   atomic.Int64
	FixedRepeatedInt16Size  atomic.Int64
	FixedRepeatedInt32Size  atomic.Int64
	FixedRepeatedInt64Size  atomic.Int64
	FixedRepeatedUint8Size  atomic.Int64
	FixedRepeatedUint16Size atomic.Int64
	FixedRepeatedUint32Size atomic.Int64
	FixedRepeatedUint64Size atomic.Int64
	ConstRepeatedUint64Size atomic.Int64
}

// CanotoSpec returns the specification of this canoto message.
func (*Scalars) CanotoSpec(types ...reflect.Type) *canoto.Spec {
	types = append(types, reflect.TypeOf(Scalars{}))
	var zero Scalars
	s := &canoto.Spec{
		Name: "Scalars",
		Fields: []*canoto.FieldType{
			{
				FieldNumber: 1,
				Name:        "Int8",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.Int8),
			},
			{
				FieldNumber: 2,
				Name:        "Int16",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.Int16),
			},
			{
				FieldNumber: 3,
				Name:        "Int32",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.Int32),
			},
			{
				FieldNumber: 4,
				Name:        "Int64",
				OneOf:       "",
				TypeInt:    canoto.SizeOf(zero.Int64),
			},
			{
				FieldNumber: 5,
				Name:        "Uint8",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint8),
			},
			{
				FieldNumber: 6,
				Name:        "Uint16",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint16),
			},
			{
				FieldNumber: 7,
				Name:        "Uint32",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint32),
			},
			{
				FieldNumber: 8,
				Name:        "Uint64",
				OneOf:       "",
				TypeUint:    canoto.SizeOf(zero.Uint64),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed32,
				/*FieldNumber:   */ 9,
				/*Name:          */ "Sfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Fixed32,
				/*FieldNumber:   */ 10,
				/*Name:          */ "Fixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed64,
				/*FieldNumber:   */ 11,
				/*Name:          */ "Sfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.Fixed64,
				/*FieldNumber:   */ 12,
				/*Name:          */ "Fixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 13,
				Name:        "Bool",
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 14,
				Name:        "String",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 15,
				Name:        "Bytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.LargestFieldNumber),
				/*FieldNumber:   */ 16,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 17,
				Name:        "RepeatedInt8",
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt8)),
			},
			{
				FieldNumber: 18,
				Name:        "RepeatedInt16",
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt16)),
			},
			{
				FieldNumber: 19,
				Name:        "RepeatedInt32",
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt32)),
			},
			{
				FieldNumber: 20,
				Name:        "RepeatedInt64",
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedInt64)),
			},
			{
				FieldNumber: 21,
				Name:        "RepeatedUint8",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint8)),
			},
			{
				FieldNumber: 22,
				Name:        "RepeatedUint16",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint16)),
			},
			{
				FieldNumber: 23,
				Name:        "RepeatedUint32",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint32)),
			},
			{
				FieldNumber: 24,
				Name:        "RepeatedUint64",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.RepeatedUint64)),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedSfixed32),
				/*FieldNumber:   */ 25,
				/*Name:          */ "RepeatedSfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedFixed32),
				/*FieldNumber:   */ 26,
				/*Name:          */ "RepeatedFixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedSfixed64),
				/*FieldNumber:   */ 27,
				/*Name:          */ "RepeatedSfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedFixed64),
				/*FieldNumber:   */ 28,
				/*Name:          */ "RepeatedFixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 29,
				Name:        "RepeatedBool",
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 30,
				Name:        "RepeatedString",
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 31,
				Name:        "RepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryPointer(zero.RepeatedLargestFieldNumber)),
				/*FieldNumber:   */ 32,
				/*Name:          */ "RepeatedLargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 33,
				Name:        "FixedRepeatedInt8",
				FixedLength: uint64(len(zero.FixedRepeatedInt8)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt8[:])),
			},
			{
				FieldNumber: 34,
				Name:        "FixedRepeatedInt16",
				FixedLength: uint64(len(zero.FixedRepeatedInt16)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt16[:])),
			},
			{
				FieldNumber: 35,
				Name:        "FixedRepeatedInt32",
				FixedLength: uint64(len(zero.FixedRepeatedInt32)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt32[:])),
			},
			{
				FieldNumber: 36,
				Name:        "FixedRepeatedInt64",
				FixedLength: uint64(len(zero.FixedRepeatedInt64)),
				Repeated:    true,
				OneOf:       "",
				TypeInt:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedInt64[:])),
			},
			{
				FieldNumber: 37,
				Name:        "FixedRepeatedUint8",
				FixedLength: uint64(len(zero.FixedRepeatedUint8)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint8[:])),
			},
			{
				FieldNumber: 38,
				Name:        "FixedRepeatedUint16",
				FixedLength: uint64(len(zero.FixedRepeatedUint16)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint16[:])),
			},
			{
				FieldNumber: 39,
				Name:        "FixedRepeatedUint32",
				FixedLength: uint64(len(zero.FixedRepeatedUint32)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint32[:])),
			},
			{
				FieldNumber: 40,
				Name:        "FixedRepeatedUint64",
				FixedLength: uint64(len(zero.FixedRepeatedUint64)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.FixedRepeatedUint64[:])),
			},
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedSfixed32[:]),
				/*FieldNumber:   */ 41,
				/*Name:          */ "FixedRepeatedSfixed32",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedSfixed32)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedFixed32[:]),
				/*FieldNumber:   */ 42,
				/*Name:          */ "FixedRepeatedFixed32",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedFixed32)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedSfixed64[:]),
				/*FieldNumber:   */ 43,
				/*Name:          */ "FixedRepeatedSfixed64",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedSfixed64)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedFixed64[:]),
				/*FieldNumber:   */ 44,
				/*Name:          */ "FixedRepeatedFixed64",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedFixed64)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 45,
				Name:        "FixedRepeatedBool",
				FixedLength: uint64(len(zero.FixedRepeatedBool)),
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 46,
				Name:        "FixedRepeatedString",
				FixedLength: uint64(len(zero.FixedRepeatedString)),
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber:    47,
				Name:           "FixedBytes",
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.FixedBytes)),
			},
			{
				FieldNumber:    48,
				Name:           "RepeatedFixedBytes",
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.RepeatedFixedBytes[0])),
			},
			{
				FieldNumber: 49,
				Name:        "FixedRepeatedBytes",
				FixedLength: uint64(len(zero.FixedRepeatedBytes)),
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    50,
				Name:           "FixedRepeatedFixedBytes",
				FixedLength:    uint64(len(zero.FixedRepeatedFixedBytes)),
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.FixedRepeatedFixedBytes[0])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntryPointer(zero.FixedRepeatedLargestFieldNumber[:])),
				/*FieldNumber:   */ 51,
				/*Name:          */ "FixedRepeatedLargestFieldNumber",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedLargestFieldNumber)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 52,
				Name:        "ConstRepeatedUint64",
				FixedLength: uint64(len(zero.ConstRepeatedUint64)),
				Repeated:    true,
				OneOf:       "",
				TypeUint:    canoto.SizeOf(canoto.MakeEntry(zero.ConstRepeatedUint64[:])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.CustomType),
				/*FieldNumber:   */ 53,
				/*Name:          */ "CustomType",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromFint(
				/*type inference:*/ zero.CustomUint32,
				/*FieldNumber:   */ 54,
				/*Name:          */ "CustomUint32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 55,
				Name:        "CustomString",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 56,
				Name:        "CustomBytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    57,
				Name:           "CustomFixedBytes",
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomFixedBytes)),
			},
			{
				FieldNumber: 58,
				Name:        "CustomRepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    59,
				Name:           "CustomRepeatedFixedBytes",
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomRepeatedFixedBytes[0])),
			},
			{
				FieldNumber: 60,
				Name:        "CustomFixedRepeatedBytes",
				FixedLength: uint64(len(zero.CustomFixedRepeatedBytes)),
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			{
				FieldNumber:    61,
				Name:           "CustomFixedRepeatedFixedBytes",
				FixedLength:    uint64(len(zero.CustomFixedRepeatedFixedBytes)),
				Repeated:       true,
				OneOf:          "",
				TypeFixedBytes: uint64(len(zero.CustomFixedRepeatedFixedBytes[0])),
			},
			canoto.FieldTypeFromField(
				/*type inference:*/ (&zero.OneOf),
				/*FieldNumber:   */ 62,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ 63,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.RepeatedPointer)),
				/*FieldNumber:   */ 64,
				/*Name:          */ "RepeatedPointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ (canoto.MakeEntry(zero.FixedRepeatedPointer[:])),
				/*FieldNumber:   */ 65,
				/*Name:          */ "FixedRepeatedPointer",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedPointer)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 66,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.RepeatedField),
				/*FieldNumber:   */ 67,
				/*Name:          */ "RepeatedField",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			canoto.FieldTypeFromField(
				/*type inference:*/ canoto.MakeEntry(zero.FixedRepeatedField[:]),
				/*FieldNumber:   */ 68,
				/*Name:          */ "FixedRepeatedField",
				/*FixedLength:   */ uint64(len(zero.FixedRepeatedField)),
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*Scalars) MakeCanoto() *Scalars {
	return new(Scalars)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *Scalars) UnmarshalCanoto(bytes []byte) error {
	r := canoto.Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a canoto.Reader. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *Scalars) UnmarshalCanotoFrom(r canoto.Reader) error {
	// Zero the struct before unmarshaling.
	*c = Scalars{}
	c.canotoData.size.Store(int64(len(r.B)))

	var minField uint32
	for canoto.HasNext(&r) {
		field, wireType, err := canoto.ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return canoto.ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int8); err != nil {
				return err
			}
			if canoto.IsZero(c.Int8) {
				return canoto.ErrZeroValue
			}
		case 2:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int16); err != nil {
				return err
			}
			if canoto.IsZero(c.Int16) {
				return canoto.ErrZeroValue
			}
		case 3:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int32); err != nil {
				return err
			}
			if canoto.IsZero(c.Int32) {
				return canoto.ErrZeroValue
			}
		case 4:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadInt(&r, &c.Int64); err != nil {
				return err
			}
			if canoto.IsZero(c.Int64) {
				return canoto.ErrZeroValue
			}
		case 5:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint8); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint8) {
				return canoto.ErrZeroValue
			}
		case 6:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint16); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint16) {
				return canoto.ErrZeroValue
			}
		case 7:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint32); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint32) {
				return canoto.ErrZeroValue
			}
		case 8:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadUint(&r, &c.Uint64); err != nil {
				return err
			}
			if canoto.IsZero(c.Uint64) {
				return canoto.ErrZeroValue
			}
		case 9:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Sfixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed32) {
				return canoto.ErrZeroValue
			}
		case 10:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.Fixed32); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed32) {
				return canoto.ErrZeroValue
			}
		case 11:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Sfixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Sfixed64) {
				return canoto.ErrZeroValue
			}
		case 12:
			if wireType != canoto.I64 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint64(&r, &c.Fixed64); err != nil {
				return err
			}
			if canoto.IsZero(c.Fixed64) {
				return canoto.ErrZeroValue
			}
		case 13:
			if wireType != canoto.Varint {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if canoto.IsZero(c.Bool) {
				return canoto.ErrZeroValue
			}
		case 14:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return canoto.ErrZeroValue
			}
		case 15:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 16:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 17:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt8 = canoto.MakeSlice(c.RepeatedInt8, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt8 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt8[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt8Size.Store(int64(len(msgBytes)))
		case 18:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt16 = canoto.MakeSlice(c.RepeatedInt16, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt16 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt16[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt16Size.Store(int64(len(msgBytes)))
		case 19:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt32 = canoto.MakeSlice(c.RepeatedInt32, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt32 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt32[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt32Size.Store(int64(len(msgBytes)))
		case 20:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt64 = canoto.MakeSlice(c.RepeatedInt64, canoto.CountInts(msgBytes))
			for i := range c.RepeatedInt64 {
				if err := canoto.ReadInt(&r, &c.RepeatedInt64[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedInt64Size.Store(int64(len(msgBytes)))
		case 21:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint8 = canoto.MakeSlice(c.RepeatedUint8, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint8 {
				if err := canoto.ReadUint(&r, &c.RepeatedUint8[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint8Size.Store(int64(len(msgBytes)))
		case 22:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint16 = canoto.MakeSlice(c.RepeatedUint16, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint16 {
				if err := canoto.ReadUint(&r, &c.RepeatedUint16[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint16Size.Store(int64(len(msgBytes)))
		case 23:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint32 = canoto.MakeSlice(c.RepeatedUint32, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint32 {
				if err := canoto.ReadUint(&r, &c.RepeatedUint32[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint32Size.Store(int64(len(msgBytes)))
		case 24:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint64 = canoto.MakeSlice(c.RepeatedUint64, canoto.CountInts(msgBytes))
			for i := range c.RepeatedUint64 {
				if err := canoto.ReadUint(&r, &c.RepeatedUint64[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			r.B = remainingBytes
			c.canotoData.RepeatedUint64Size.Store(int64(len(msgBytes)))
		case 25:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed32 = canoto.MakeSlice(c.RepeatedSfixed32, int(numMsgBytes/canoto.SizeFint32))
			for i := range c.RepeatedSfixed32 {
				if err := canoto.ReadFint32(&r, &c.RepeatedSfixed32[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 26:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint32 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed32 = canoto.MakeSlice(c.RepeatedFixed32, int(numMsgBytes/canoto.SizeFint32))
			for i := range c.RepeatedFixed32 {
				if err := canoto.ReadFint32(&r, &c.RepeatedFixed32[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 27:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed64 = canoto.MakeSlice(c.RepeatedSfixed64, int(numMsgBytes/canoto.SizeFint64))
			for i := range c.RepeatedSfixed64 {
				if err := canoto.ReadFint64(&r, &c.RepeatedSfixed64[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 28:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeFint64 != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed64 = canoto.MakeSlice(c.RepeatedFixed64, int(numMsgBytes/canoto.SizeFint64))
			for i := range c.RepeatedFixed64 {
				if err := canoto.ReadFint64(&r, &c.RepeatedFixed64[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 29:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint(len(msgBytes))
			if numMsgBytes == 0 {
				return canoto.ErrZeroValue
			}
			if numMsgBytes%canoto.SizeBool != 0 {
				return canoto.ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = canoto.MakeSlice(c.RepeatedBool, int(numMsgBytes/canoto.SizeBool))
			for i := range c.RepeatedBool {
				if err := canoto.ReadBool(&r, &c.RepeatedBool[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 30:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = canoto.MakeSlice(c.RepeatedString, countMinus1+1)

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadString(&r, &c.RepeatedString[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedString__tag):]
				if err := canoto.ReadString(&r, &c.RepeatedString[1+i]); err != nil {
					return err
				}
			}
		case 31:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = canoto.MakeSlice(c.RepeatedBytes, countMinus1+1)

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &c.RepeatedBytes[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &c.RepeatedBytes[1+i]); err != nil {
					return err
				}
			}
		case 32:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedLargestFieldNumber__tag)
			if err != nil {
				return err
			}

			c.RepeatedLargestFieldNumber = canoto.MakeSlice(c.RepeatedLargestFieldNumber, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedLargestFieldNumber[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.RepeatedLargestFieldNumber[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 33:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt8 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt8Size.Store(int64(len(msgBytes)))
		case 34:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt16 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt16Size.Store(int64(len(msgBytes)))
		case 35:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt32 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt32Size.Store(int64(len(msgBytes)))
		case 36:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedInt64 {
				if err := canoto.ReadInt(&r, &(&c.FixedRepeatedInt64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedInt64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedInt64Size.Store(int64(len(msgBytes)))
		case 37:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint8 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint8)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint8) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint8Size.Store(int64(len(msgBytes)))
		case 38:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint16 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint16)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint16) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint16Size.Store(int64(len(msgBytes)))
		case 39:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint32 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint32Size.Store(int64(len(msgBytes)))
		case 40:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedUint64 {
				if err := canoto.ReadUint(&r, &(&c.FixedRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.FixedRepeatedUint64Size.Store(int64(len(msgBytes)))
		case 41:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedSfixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedSfixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 42:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed32 {
				if err := canoto.ReadFint32(&r, &(&c.FixedRepeatedFixed32)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedFixed32) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 43:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedSfixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedSfixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedSfixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 44:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedFixed64 {
				if err := canoto.ReadFint64(&r, &(&c.FixedRepeatedFixed64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedFixed64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 45:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.FixedRepeatedBool {
				if err := canoto.ReadBool(&r, &(&c.FixedRepeatedBool)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.FixedRepeatedBool) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
		case 46:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadString(&r, &(&c.FixedRepeatedString)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedString)[0]) == 0
			const numToRead = uint(len(c.FixedRepeatedString) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedString__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedString__tag):]
				if err := canoto.ReadString(&r, &(&c.FixedRepeatedString)[1+i]); err != nil {
					return err
				}
				isZero = isZero && len((&c.FixedRepeatedString)[1+i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 47:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.FixedBytes)
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.FixedBytes)[:], r.B)
			if canoto.IsZero(c.FixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case 48:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.RepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.RepeatedFixedBytes = canoto.MakeSlice(c.RepeatedFixedBytes, countMinus1+1)
			copy((&c.RepeatedFixedBytes[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedFixedBytes__tag):]
				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&c.RepeatedFixedBytes[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
		case 49:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.FixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.FixedRepeatedBytes)[0]) == 0
			const numToRead = uint(len(c.FixedRepeatedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &(&c.FixedRepeatedBytes)[1+i]); err != nil {
					return err
				}
				isZero = isZero && len((&c.FixedRepeatedBytes)[1+i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 50:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.FixedRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&(&c.FixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = r.B[expectedLength:]

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedFixedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&(&c.FixedRepeatedFixedBytes)[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
			if canoto.IsZero(c.FixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case 51:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedLargestFieldNumber[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedLargestFieldNumber) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&c.FixedRepeatedLargestFieldNumber[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 52:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			for i := range &c.ConstRepeatedUint64 {
				if err := canoto.ReadUint(&r, &(&c.ConstRepeatedUint64)[i]); err != nil {
					return err
				}
			}
			if canoto.HasNext(&r) {
				return canoto.ErrInvalidLength
			}
			if canoto.IsZero(c.ConstRepeatedUint64) {
				return canoto.ErrZeroValue
			}
			r.B = remainingBytes
			c.canotoData.ConstRepeatedUint64Size.Store(int64(len(msgBytes)))
		case 53:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.CustomType).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 54:
			if wireType != canoto.I32 {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadFint32(&r, &c.CustomUint32); err != nil {
				return err
			}
			if canoto.IsZero(c.CustomUint32) {
				return canoto.ErrZeroValue
			}
		case 55:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadString(&r, &c.CustomString); err != nil {
				return err
			}
			if len(c.CustomString) == 0 {
				return canoto.ErrZeroValue
			}
		case 56:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			if err := canoto.ReadBytes(&r, &c.CustomBytes); err != nil {
				return err
			}
			if len(c.CustomBytes) == 0 {
				return canoto.ErrZeroValue
			}
		case 57:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomFixedBytes)
				expectedLengthUint64 = uint64(expectedLength)
			)
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&c.CustomFixedBytes)[:], r.B)
			if canoto.IsZero(c.CustomFixedBytes) {
				return canoto.ErrZeroValue
			}
			r.B = r.B[expectedLength:]
		case 58:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := canoto.ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.CustomRepeatedBytes = canoto.MakeSlice(c.CustomRepeatedBytes, countMinus1+1)

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := canoto.ReadBytes(&r, &c.CustomRepeatedBytes[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &c.CustomRepeatedBytes[1+i]); err != nil {
					return err
				}
			}
		case 59:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			firstEntry := r.B[:expectedLength]
			r.B = r.B[expectedLength:]

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__CustomRepeatedFixedBytes__tag)
			if err != nil {
				return err
			}

			c.CustomRepeatedFixedBytes = canoto.MakeSlice(c.CustomRepeatedFixedBytes, countMinus1+1)
			copy((&c.CustomRepeatedFixedBytes[0])[:], firstEntry)

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__CustomRepeatedFixedBytes__tag):]
				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&c.CustomRepeatedFixedBytes[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
		case 60:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			if err := canoto.ReadBytes(&r, &(&c.CustomFixedRepeatedBytes)[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			isZero := len((&c.CustomFixedRepeatedBytes)[0]) == 0
			const numToRead = uint(len(c.CustomFixedRepeatedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedBytes__tag):]
				if err := canoto.ReadBytes(&r, &(&c.CustomFixedRepeatedBytes)[1+i]); err != nil {
					return err
				}
				isZero = isZero && len((&c.CustomFixedRepeatedBytes)[1+i]) == 0
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 61:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			const (
				expectedLength       = len(c.CustomFixedRepeatedFixedBytes[0])
				expectedLengthUint64 = uint64(expectedLength)
			)

			// Read the first entry manually because the tag is already
			// stripped.
			var length uint64
			if err := canoto.ReadUint(&r, &length); err != nil {
				return err
			}
			if length != expectedLengthUint64 {
				return canoto.ErrInvalidLength
			}
			if expectedLength > len(r.B) {
				return io.ErrUnexpectedEOF
			}

			copy((&(&c.CustomFixedRepeatedFixedBytes)[0])[:], r.B)
			r.B = r.B[expectedLength:]

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.CustomFixedRepeatedFixedBytes) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag):]

				if err := canoto.ReadUint(&r, &length); err != nil {
					return err
				}
				if length != expectedLengthUint64 {
					return canoto.ErrInvalidLength
				}
				if expectedLength > len(r.B) {
					return io.ErrUnexpectedEOF
				}

				copy((&(&c.CustomFixedRepeatedFixedBytes)[1+i])[:], r.B)
				r.B = r.B[expectedLength:]
			}
			if canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
				return canoto.ErrZeroValue
			}
		case 62:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			if err := (&c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 63:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = canoto.MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 64:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedPointer__tag)
			if err != nil {
				return err
			}

			c.RepeatedPointer = canoto.MakeSlice(c.RepeatedPointer, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[0] = canoto.MakePointer(c.RepeatedPointer[0])
				if err := (c.RepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedPointer[1+i] = canoto.MakePointer(c.RepeatedPointer[1+i])
				if err := (c.RepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 65:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[0] = canoto.MakePointer(c.FixedRepeatedPointer[0])
				if err := (c.FixedRepeatedPointer[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedPointer) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedPointer__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedPointer__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedPointer[1+i] = canoto.MakePointer(c.FixedRepeatedPointer[1+i])
				if err := (c.FixedRepeatedPointer[1+i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		case 66:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return canoto.ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 67:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := canoto.CountBytes(r.B, canoto__Scalars__RepeatedField__tag)
			if err != nil {
				return err
			}

			c.RepeatedField = canoto.MakeSlice(c.RepeatedField, countMinus1+1)
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[0] = c.RepeatedField[0].MakeCanoto()
				if err := c.RepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range countMinus1 {
				r.B = r.B[len(canoto__Scalars__RepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.RepeatedField[1+i] = c.RepeatedField[1+i].MakeCanoto()
				if err := c.RepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 68:
			if wireType != canoto.Len {
				return canoto.ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			isZero := len(msgBytes) == 0
			if !isZero {
				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[0] = c.FixedRepeatedField[0].MakeCanoto()
				if err := c.FixedRepeatedField[0].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			const numToRead = uint(len(c.FixedRepeatedField) - 1)
			for i := range numToRead {
				if !canoto.HasPrefix(r.B, canoto__Scalars__FixedRepeatedField__tag) {
					return canoto.ErrUnknownField
				}
				r.B = r.B[len(canoto__Scalars__FixedRepeatedField__tag):]
				r.Unsafe = true
				if err := canoto.ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				c.FixedRepeatedField[1+i] = c.FixedRepeatedField[1+i].MakeCanoto()
				if err := c.FixedRepeatedField[1+i].UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
				isZero = false
			}
			if isZero {
				return canoto.ErrZeroValue
			}
		default:
			return canoto.ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *Scalars) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !utf8.ValidString(string(c.String)) {
		return false
	}
	if !(&c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	for _, v := range c.RepeatedString {
		if !utf8.ValidString(string(v)) {
			return false
		}
	}
	for i := range c.RepeatedLargestFieldNumber {
		if !(&c.RepeatedLargestFieldNumber[i]).ValidCanoto() {
			return false
		}
	}
	for _, v := range &c.FixedRepeatedString {
		if !utf8.ValidString(string(v)) {
			return false
		}
	}
	for i := range &c.FixedRepeatedLargestFieldNumber {
		if !(&(&c.FixedRepeatedLargestFieldNumber)[i]).ValidCanoto() {
			return false
		}
	}
	if !(&c.CustomType).ValidCanoto() {
		return false
	}
	if !utf8.ValidString(string(c.CustomString)) {
		return false
	}
	if !(&c.OneOf).ValidCanoto() {
		return false
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	for i := range c.RepeatedPointer {
		if c.RepeatedPointer[i] != nil && !(c.RepeatedPointer[i]).ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedPointer {
		if (&c.FixedRepeatedPointer)[i] != nil && !((&c.FixedRepeatedPointer)[i]).ValidCanoto() {
			return false
		}
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	for i := range c.RepeatedField {
		if !c.RepeatedField[i].ValidCanoto() {
			return false
		}
	}
	for i := range &c.FixedRepeatedField {
		if !(&c.FixedRepeatedField)[i].ValidCanoto() {
			return false
		}
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
func (c *Scalars) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var (
		size int
	)
	if !canoto.IsZero(c.Int8) {
		size += len(canoto__Scalars__Int8__tag) + canoto.SizeInt(c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		size += len(canoto__Scalars__Int16__tag) + canoto.SizeInt(c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		size += len(canoto__Scalars__Int32__tag) + canoto.SizeInt(c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		size += len(canoto__Scalars__Int64__tag) + canoto.SizeInt(c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		size += len(canoto__Scalars__Uint8__tag) + canoto.SizeUint(c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		size += len(canoto__Scalars__Uint16__tag) + canoto.SizeUint(c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		size += len(canoto__Scalars__Uint32__tag) + canoto.SizeUint(c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		size += len(canoto__Scalars__Uint64__tag) + canoto.SizeUint(c.Uint64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		size += len(canoto__Scalars__Sfixed32__tag) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Fixed32) {
		size += len(canoto__Scalars__Fixed32__tag) + canoto.SizeFint32
	}
	if !canoto.IsZero(c.Sfixed64) {
		size += len(canoto__Scalars__Sfixed64__tag) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Fixed64) {
		size += len(canoto__Scalars__Fixed64__tag) + canoto.SizeFint64
	}
	if !canoto.IsZero(c.Bool) {
		size += len(canoto__Scalars__Bool__tag) + canoto.SizeBool
	}
	if len(c.String) != 0 {
		size += len(canoto__Scalars__String__tag) + canoto.SizeBytes(c.String)
	}
	if len(c.Bytes) != 0 {
		size += len(canoto__Scalars__Bytes__tag) + canoto.SizeBytes(c.Bytes)
	}
	(&c.LargestFieldNumber).CalculateCanotoCache()
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__Scalars__LargestFieldNumber__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if len(c.RepeatedInt8) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedInt8 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__RepeatedInt8__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedInt8Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedInt16) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedInt16 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__RepeatedInt16__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedInt16Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedInt32) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedInt32 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__RepeatedInt32__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedInt32Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedInt64) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedInt64 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__RepeatedInt64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedInt64Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedUint8) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedUint8 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__RepeatedUint8__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedUint8Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedUint16) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedUint16 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__RepeatedUint16__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedUint16Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedUint32) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedUint32 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__RepeatedUint32__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedUint32Size.Store(int64(fieldSize))
	}
	if len(c.RepeatedUint64) != 0 {
		var fieldSize int
		for _, v := range c.RepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__RepeatedUint64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.RepeatedUint64Size.Store(int64(fieldSize))
	}
	if num := len(c.RepeatedSfixed32); num != 0 {
		fieldSize := num * canoto.SizeFint32
		size += len(canoto__Scalars__RepeatedSfixed32__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedFixed32); num != 0 {
		fieldSize := num * canoto.SizeFint32
		size += len(canoto__Scalars__RepeatedFixed32__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedSfixed64); num != 0 {
		fieldSize := num * canoto.SizeFint64
		size += len(canoto__Scalars__RepeatedSfixed64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedFixed64); num != 0 {
		fieldSize := num * canoto.SizeFint64
		size += len(canoto__Scalars__RepeatedFixed64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if num := len(c.RepeatedBool); num != 0 {
		fieldSize := num * canoto.SizeBool
		size += len(canoto__Scalars__RepeatedBool__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	for _, v := range c.RepeatedString {
		size += len(canoto__Scalars__RepeatedString__tag) + canoto.SizeBytes(v)
	}
	for _, v := range c.RepeatedBytes {
		size += len(canoto__Scalars__RepeatedBytes__tag) + canoto.SizeBytes(v)
	}
	for i := range c.RepeatedLargestFieldNumber {
		(&c.RepeatedLargestFieldNumber[i]).CalculateCanotoCache()
		fieldSize := (&c.RepeatedLargestFieldNumber[i]).CachedCanotoSize()
		size += len(canoto__Scalars__RepeatedLargestFieldNumber__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedInt8 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__FixedRepeatedInt8__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedInt8Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedInt16 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__FixedRepeatedInt16__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedInt16Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedInt32 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__FixedRepeatedInt32__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedInt32Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedInt64 {
			fieldSize += canoto.SizeInt(v)
		}
		size += len(canoto__Scalars__FixedRepeatedInt64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedInt64Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedUint8 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__FixedRepeatedUint8__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedUint8Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedUint16 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__FixedRepeatedUint16__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedUint16Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedUint32 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__FixedRepeatedUint32__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedUint32Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		var fieldSize int
		for _, v := range &c.FixedRepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__FixedRepeatedUint64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.FixedRepeatedUint64Size.Store(int64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = len(c.FixedRepeatedSfixed32) * canoto.SizeFint32
		size += len(canoto__Scalars__FixedRepeatedSfixed32__tag) + fieldSize + canoto.SizeUint(uint64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = len(c.FixedRepeatedFixed32) * canoto.SizeFint32
		size += len(canoto__Scalars__FixedRepeatedFixed32__tag) + fieldSize + canoto.SizeUint(uint64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = len(c.FixedRepeatedSfixed64) * canoto.SizeFint64
		size += len(canoto__Scalars__FixedRepeatedSfixed64__tag) + fieldSize + canoto.SizeUint(uint64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = len(c.FixedRepeatedFixed64) * canoto.SizeFint64
		size += len(canoto__Scalars__FixedRepeatedFixed64__tag) + fieldSize + canoto.SizeUint(uint64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = len(c.FixedRepeatedBool) * canoto.SizeBool
		size += len(canoto__Scalars__FixedRepeatedBool__tag) + fieldSize + canoto.SizeUint(uint64(fieldSize))
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			size += len(canoto__Scalars__FixedRepeatedString__tag) + canoto.SizeBytes(v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		size += len(canoto__Scalars__FixedBytes__tag) + canoto.SizeBytes((&c.FixedBytes)[:])
	}
	if num := len(c.RepeatedFixedBytes); num != 0 {
		fieldSize := len(canoto__Scalars__RepeatedFixedBytes__tag) + canoto.SizeBytes((&c.RepeatedFixedBytes[0])[:])
		size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				size += len(canoto__Scalars__FixedRepeatedBytes__tag) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			size += len(canoto__Scalars__FixedRepeatedFixedBytes__tag) + canoto.SizeBytes((&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedLargestFieldNumber {
			(&c.FixedRepeatedLargestFieldNumber[i]).CalculateCanotoCache()
			fieldSize := (&c.FixedRepeatedLargestFieldNumber[i]).CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__Scalars__FixedRepeatedLargestFieldNumber__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		var fieldSize int
		for _, v := range &c.ConstRepeatedUint64 {
			fieldSize += canoto.SizeUint(v)
		}
		size += len(canoto__Scalars__ConstRepeatedUint64__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		c.canotoData.ConstRepeatedUint64Size.Store(int64(fieldSize))
	}
	(&c.CustomType).CalculateCanotoCache()
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__Scalars__CustomType__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if !canoto.IsZero(c.CustomUint32) {
		size += len(canoto__Scalars__CustomUint32__tag) + canoto.SizeFint32
	}
	if len(c.CustomString) != 0 {
		size += len(canoto__Scalars__CustomString__tag) + canoto.SizeBytes(c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		size += len(canoto__Scalars__CustomBytes__tag) + canoto.SizeBytes(c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		size += len(canoto__Scalars__CustomFixedBytes__tag) + canoto.SizeBytes((&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		size += len(canoto__Scalars__CustomRepeatedBytes__tag) + canoto.SizeBytes(v)
	}
	if num := len(c.CustomRepeatedFixedBytes); num != 0 {
		fieldSize := len(canoto__Scalars__CustomRepeatedFixedBytes__tag) + canoto.SizeBytes((&c.CustomRepeatedFixedBytes[0])[:])
		size += num * fieldSize
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				size += len(canoto__Scalars__CustomFixedRepeatedBytes__tag) + canoto.SizeBytes(v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			size += len(canoto__Scalars__CustomFixedRepeatedFixedBytes__tag) + canoto.SizeBytes((&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	(&c.OneOf).CalculateCanotoCache()
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__Scalars__OneOf__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += len(canoto__Scalars__Pointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
	}
	for i := range c.RepeatedPointer {
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			(c.RepeatedPointer[i]).CalculateCanotoCache()
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		size += len(canoto__Scalars__RepeatedPointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedPointer {
			var fieldSize int
			if c.FixedRepeatedPointer[i] != nil {
				(c.FixedRepeatedPointer[i]).CalculateCanotoCache()
				fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				fieldSizeSum += fieldSize
			}
			totalSize += len(canoto__Scalars__FixedRepeatedPointer__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += len(canoto__Scalars__Field__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	for i := range c.RepeatedField {
		c.RepeatedField[i].CalculateCanotoCache()
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		size += len(canoto__Scalars__RepeatedField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
	}
	{
		var (
			fieldSizeSum int
			totalSize    int
		)
		for i := range c.FixedRepeatedField {
			c.FixedRepeatedField[i].CalculateCanotoCache()
			fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
			fieldSizeSum += fieldSize
			totalSize += len(canoto__Scalars__FixedRepeatedField__tag) + canoto.SizeUint(uint64(fieldSize)) + fieldSize
		}
		if fieldSizeSum != 0 {
			size += totalSize
		}
	}
	c.canotoData.size.Store(int64(size))
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *Scalars) CachedCanotoSize() int {
	if c == nil {
		return 0
	}
	return int(c.canotoData.size.Load())
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Scalars) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := canoto.Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a canoto.Writer and returns the
// resulting canoto.Writer. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
func (c *Scalars) MarshalCanotoInto(w canoto.Writer) canoto.Writer {
	if c == nil {
		return w
	}
	if !canoto.IsZero(c.Int8) {
		canoto.Append(&w, canoto__Scalars__Int8__tag)
		canoto.AppendInt(&w, c.Int8)
	}
	if !canoto.IsZero(c.Int16) {
		canoto.Append(&w, canoto__Scalars__Int16__tag)
		canoto.AppendInt(&w, c.Int16)
	}
	if !canoto.IsZero(c.Int32) {
		canoto.Append(&w, canoto__Scalars__Int32__tag)
		canoto.AppendInt(&w, c.Int32)
	}
	if !canoto.IsZero(c.Int64) {
		canoto.Append(&w, canoto__Scalars__Int64__tag)
		canoto.AppendInt(&w, c.Int64)
	}
	if !canoto.IsZero(c.Uint8) {
		canoto.Append(&w, canoto__Scalars__Uint8__tag)
		canoto.AppendUint(&w, c.Uint8)
	}
	if !canoto.IsZero(c.Uint16) {
		canoto.Append(&w, canoto__Scalars__Uint16__tag)
		canoto.AppendUint(&w, c.Uint16)
	}
	if !canoto.IsZero(c.Uint32) {
		canoto.Append(&w, canoto__Scalars__Uint32__tag)
		canoto.AppendUint(&w, c.Uint32)
	}
	if !canoto.IsZero(c.Uint64) {
		canoto.Append(&w, canoto__Scalars__Uint64__tag)
		canoto.AppendUint(&w, c.Uint64)
	}
	if !canoto.IsZero(c.Sfixed32) {
		canoto.Append(&w, canoto__Scalars__Sfixed32__tag)
		canoto.AppendFint32(&w, c.Sfixed32)
	}
	if !canoto.IsZero(c.Fixed32) {
		canoto.Append(&w, canoto__Scalars__Fixed32__tag)
		canoto.AppendFint32(&w, c.Fixed32)
	}
	if !canoto.IsZero(c.Sfixed64) {
		canoto.Append(&w, canoto__Scalars__Sfixed64__tag)
		canoto.AppendFint64(&w, c.Sfixed64)
	}
	if !canoto.IsZero(c.Fixed64) {
		canoto.Append(&w, canoto__Scalars__Fixed64__tag)
		canoto.AppendFint64(&w, c.Fixed64)
	}
	if !canoto.IsZero(c.Bool) {
		canoto.Append(&w, canoto__Scalars__Bool__tag)
		canoto.AppendBool(&w, true)
	}
	if len(c.String) != 0 {
		canoto.Append(&w, canoto__Scalars__String__tag)
		canoto.AppendBytes(&w, c.String)
	}
	if len(c.Bytes) != 0 {
		canoto.Append(&w, canoto__Scalars__Bytes__tag)
		canoto.AppendBytes(&w, c.Bytes)
	}
	if fieldSize := (&c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__LargestFieldNumber__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = (&c.LargestFieldNumber).MarshalCanotoInto(w)
	}
	if len(c.RepeatedInt8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt8__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedInt8Size.Load()))
		for _, v := range c.RepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt16__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedInt16Size.Load()))
		for _, v := range c.RepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt32__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedInt32Size.Load()))
		for _, v := range c.RepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedInt64__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedInt64Size.Load()))
		for _, v := range c.RepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint8) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint8__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedUint8Size.Load()))
		for _, v := range c.RepeatedUint8 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint16) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint16__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedUint16Size.Load()))
		for _, v := range c.RepeatedUint16 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint32) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint32__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedUint32Size.Load()))
		for _, v := range c.RepeatedUint32 {
			canoto.AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint64) != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedUint64__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.RepeatedUint64Size.Load()))
		for _, v := range c.RepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if num := len(c.RepeatedSfixed32); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed32__tag)
		canoto.AppendUint(&w, uint64(num*canoto.SizeFint32))
		for _, v := range c.RepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := len(c.RepeatedFixed32); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed32__tag)
		canoto.AppendUint(&w, uint64(num*canoto.SizeFint32))
		for _, v := range c.RepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if num := len(c.RepeatedSfixed64); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedSfixed64__tag)
		canoto.AppendUint(&w, uint64(num*canoto.SizeFint64))
		for _, v := range c.RepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := len(c.RepeatedFixed64); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedFixed64__tag)
		canoto.AppendUint(&w, uint64(num*canoto.SizeFint64))
		for _, v := range c.RepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if num := len(c.RepeatedBool); num != 0 {
		canoto.Append(&w, canoto__Scalars__RepeatedBool__tag)
		canoto.AppendUint(&w, uint64(num*canoto.SizeBool))
		for _, v := range c.RepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	for _, v := range c.RepeatedString {
		canoto.Append(&w, canoto__Scalars__RepeatedString__tag)
		canoto.AppendBytes(&w, v)
	}
	for _, v := range c.RepeatedBytes {
		canoto.Append(&w, canoto__Scalars__RepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	for i := range c.RepeatedLargestFieldNumber {
		canoto.Append(&w, canoto__Scalars__RepeatedLargestFieldNumber__tag)
		canoto.AppendUint(&w, uint64((&c.RepeatedLargestFieldNumber[i]).CachedCanotoSize()))
		w = (&c.RepeatedLargestFieldNumber[i]).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.FixedRepeatedInt8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt8__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedInt8Size.Load()))
		for _, v := range &c.FixedRepeatedInt8 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt16__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedInt16Size.Load()))
		for _, v := range &c.FixedRepeatedInt16 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt32__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedInt32Size.Load()))
		for _, v := range &c.FixedRepeatedInt32 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedInt64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedInt64__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedInt64Size.Load()))
		for _, v := range &c.FixedRepeatedInt64 {
			canoto.AppendInt(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint8) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint8__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedUint8Size.Load()))
		for _, v := range &c.FixedRepeatedUint8 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint16) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint16__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedUint16Size.Load()))
		for _, v := range &c.FixedRepeatedUint16 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint32) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint32__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedUint32Size.Load()))
		for _, v := range &c.FixedRepeatedUint32 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__FixedRepeatedUint64__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.FixedRepeatedUint64Size.Load()))
		for _, v := range &c.FixedRepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed32) {
		const fieldSize = len(c.FixedRepeatedSfixed32) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed32__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		for _, v := range &c.FixedRepeatedSfixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed32) {
		const fieldSize = len(c.FixedRepeatedFixed32) * canoto.SizeFint32
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed32__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		for _, v := range &c.FixedRepeatedFixed32 {
			canoto.AppendFint32(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedSfixed64) {
		const fieldSize = len(c.FixedRepeatedSfixed64) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedSfixed64__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		for _, v := range &c.FixedRepeatedSfixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixed64) {
		const fieldSize = len(c.FixedRepeatedFixed64) * canoto.SizeFint64
		canoto.Append(&w, canoto__Scalars__FixedRepeatedFixed64__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		for _, v := range &c.FixedRepeatedFixed64 {
			canoto.AppendFint64(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedBool) {
		const fieldSize = len(c.FixedRepeatedBool) * canoto.SizeBool
		canoto.Append(&w, canoto__Scalars__FixedRepeatedBool__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		for _, v := range &c.FixedRepeatedBool {
			canoto.AppendBool(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedRepeatedString) {
		for _, v := range &c.FixedRepeatedString {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedString__tag)
			canoto.AppendBytes(&w, v)
		}
	}
	if !canoto.IsZero(c.FixedBytes) {
		canoto.Append(&w, canoto__Scalars__FixedBytes__tag)
		canoto.AppendBytes(&w, (&c.FixedBytes)[:])
	}
	for i := range c.RepeatedFixedBytes {
		canoto.Append(&w, canoto__Scalars__RepeatedFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.RepeatedFixedBytes[i])[:])
	}
	{
		isZero := true
		for _, v := range c.FixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.FixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.FixedRepeatedFixedBytes) {
		for i := range c.FixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__FixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.FixedRepeatedFixedBytes)[i])[:])
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedLargestFieldNumber {
			if (&c.FixedRepeatedLargestFieldNumber[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedLargestFieldNumber {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedLargestFieldNumber__tag)
				canoto.AppendUint(&w, uint64((&c.FixedRepeatedLargestFieldNumber[i]).CachedCanotoSize()))
				w = (&c.FixedRepeatedLargestFieldNumber[i]).MarshalCanotoInto(w)
			}
		}
	}
	if !canoto.IsZero(c.ConstRepeatedUint64) {
		canoto.Append(&w, canoto__Scalars__ConstRepeatedUint64__tag)
		canoto.AppendUint(&w, uint64(c.canotoData.ConstRepeatedUint64Size.Load()))
		for _, v := range &c.ConstRepeatedUint64 {
			canoto.AppendUint(&w, v)
		}
	}
	if fieldSize := (&c.CustomType).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__CustomType__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = (&c.CustomType).MarshalCanotoInto(w)
	}
	if !canoto.IsZero(c.CustomUint32) {
		canoto.Append(&w, canoto__Scalars__CustomUint32__tag)
		canoto.AppendFint32(&w, c.CustomUint32)
	}
	if len(c.CustomString) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomString__tag)
		canoto.AppendBytes(&w, c.CustomString)
	}
	if len(c.CustomBytes) != 0 {
		canoto.Append(&w, canoto__Scalars__CustomBytes__tag)
		canoto.AppendBytes(&w, c.CustomBytes)
	}
	if !canoto.IsZero(c.CustomFixedBytes) {
		canoto.Append(&w, canoto__Scalars__CustomFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.CustomFixedBytes)[:])
	}
	for _, v := range c.CustomRepeatedBytes {
		canoto.Append(&w, canoto__Scalars__CustomRepeatedBytes__tag)
		canoto.AppendBytes(&w, v)
	}
	for i := range c.CustomRepeatedFixedBytes {
		canoto.Append(&w, canoto__Scalars__CustomRepeatedFixedBytes__tag)
		canoto.AppendBytes(&w, (&c.CustomRepeatedFixedBytes[i])[:])
	}
	{
		isZero := true
		for _, v := range c.CustomFixedRepeatedBytes {
			if len(v) != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for _, v := range c.CustomFixedRepeatedBytes {
				canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedBytes__tag)
				canoto.AppendBytes(&w, v)
			}
		}
	}
	if !canoto.IsZero(c.CustomFixedRepeatedFixedBytes) {
		for i := range c.CustomFixedRepeatedFixedBytes {
			canoto.Append(&w, canoto__Scalars__CustomFixedRepeatedFixedBytes__tag)
			canoto.AppendBytes(&w, (&(&c.CustomFixedRepeatedFixedBytes)[i])[:])
		}
	}
	if fieldSize := (&c.OneOf).CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__OneOf__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = (&c.OneOf).MarshalCanotoInto(w)
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			canoto.Append(&w, canoto__Scalars__Pointer__tag)
			canoto.AppendUint(&w, uint64(fieldSize))
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	for i := range c.RepeatedPointer {
		canoto.Append(&w, canoto__Scalars__RepeatedPointer__tag)
		var fieldSize int
		if c.RepeatedPointer[i] != nil {
			fieldSize = (c.RepeatedPointer[i]).CachedCanotoSize()
		}
		canoto.AppendUint(&w, uint64(fieldSize))
		if fieldSize != 0 {
			w = (c.RepeatedPointer[i]).MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedPointer {
			if c.FixedRepeatedPointer[i] != nil && (c.FixedRepeatedPointer[i]).CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedPointer {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedPointer__tag)
				var fieldSize int
				if c.FixedRepeatedPointer[i] != nil {
					fieldSize = (c.FixedRepeatedPointer[i]).CachedCanotoSize()
				}
				canoto.AppendUint(&w, uint64(fieldSize))
				if fieldSize != 0 {
					w = (c.FixedRepeatedPointer[i]).MarshalCanotoInto(w)
				}
			}
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		canoto.Append(&w, canoto__Scalars__Field__tag)
		canoto.AppendUint(&w, uint64(fieldSize))
		w = c.Field.MarshalCanotoInto(w)
	}
	for i := range c.RepeatedField {
		canoto.Append(&w, canoto__Scalars__RepeatedField__tag)
		fieldSize := c.RepeatedField[i].CachedCanotoSize()
		canoto.AppendUint(&w, uint64(fieldSize))
		if fieldSize != 0 {
			w = c.RepeatedField[i].MarshalCanotoInto(w)
		}
	}
	{
		isZero := true
		for i := range c.FixedRepeatedField {
			if c.FixedRepeatedField[i].CachedCanotoSize() != 0 {
				isZero = false
				break
			}
		}
		if !isZero {
			for i := range c.FixedRepeatedField {
				canoto.Append(&w, canoto__Scalars__FixedRepeatedField__tag)
				fieldSize := c.FixedRepeatedField[i].CachedCanotoSize()
				canoto.AppendUint(&w, uint64(fieldSize))
				if fieldSize != 0 {
					w = c.FixedRepeatedField[i].MarshalCanotoInto(w)
				}
			}
		}
	}
	return w
}
