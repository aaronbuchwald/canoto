// Code generated by canoto. DO NOT EDIT.
// versions:
// 	canoto v0.17.1
// source: canoto_test.go

package canoto

import (
	"io"
	"reflect"
	"sync/atomic"
)

// Ensure that unused imports do not error
var (
	_ atomic.Uint64

	_ = io.ErrUnexpectedEOF
)

const (
	canoto__SpecFuzzer__Int8__tag                       = "\x08"     // canoto.Tag(1, canoto.Varint)
	canoto__SpecFuzzer__Int16__tag                      = "\x10"     // canoto.Tag(2, canoto.Varint)
	canoto__SpecFuzzer__Int32__tag                      = "\x18"     // canoto.Tag(3, canoto.Varint)
	canoto__SpecFuzzer__Int64__tag                      = "\x20"     // canoto.Tag(4, canoto.Varint)
	canoto__SpecFuzzer__Uint8__tag                      = "\x28"     // canoto.Tag(5, canoto.Varint)
	canoto__SpecFuzzer__Uint16__tag                     = "\x30"     // canoto.Tag(6, canoto.Varint)
	canoto__SpecFuzzer__Uint32__tag                     = "\x38"     // canoto.Tag(7, canoto.Varint)
	canoto__SpecFuzzer__Uint64__tag                     = "\x40"     // canoto.Tag(8, canoto.Varint)
	canoto__SpecFuzzer__Sfixed32__tag                   = "\x4d"     // canoto.Tag(9, canoto.I32)
	canoto__SpecFuzzer__Fixed32__tag                    = "\x55"     // canoto.Tag(10, canoto.I32)
	canoto__SpecFuzzer__Sfixed64__tag                   = "\x59"     // canoto.Tag(11, canoto.I64)
	canoto__SpecFuzzer__Fixed64__tag                    = "\x61"     // canoto.Tag(12, canoto.I64)
	canoto__SpecFuzzer__Bool__tag                       = "\x68"     // canoto.Tag(13, canoto.Varint)
	canoto__SpecFuzzer__String__tag                     = "\x72"     // canoto.Tag(14, canoto.Len)
	canoto__SpecFuzzer__Bytes__tag                      = "\x7a"     // canoto.Tag(15, canoto.Len)
	canoto__SpecFuzzer__LargestFieldNumber__tag         = "\x82\x01" // canoto.Tag(16, canoto.Len)
	canoto__SpecFuzzer__RepeatedInt8__tag               = "\x8a\x01" // canoto.Tag(17, canoto.Len)
	canoto__SpecFuzzer__RepeatedInt16__tag              = "\x92\x01" // canoto.Tag(18, canoto.Len)
	canoto__SpecFuzzer__RepeatedInt32__tag              = "\x9a\x01" // canoto.Tag(19, canoto.Len)
	canoto__SpecFuzzer__RepeatedInt64__tag              = "\xa2\x01" // canoto.Tag(20, canoto.Len)
	canoto__SpecFuzzer__RepeatedUint16__tag             = "\xaa\x01" // canoto.Tag(21, canoto.Len)
	canoto__SpecFuzzer__RepeatedUint32__tag             = "\xb2\x01" // canoto.Tag(22, canoto.Len)
	canoto__SpecFuzzer__RepeatedUint64__tag             = "\xba\x01" // canoto.Tag(23, canoto.Len)
	canoto__SpecFuzzer__RepeatedSfixed32__tag           = "\xc2\x01" // canoto.Tag(24, canoto.Len)
	canoto__SpecFuzzer__RepeatedFixed32__tag            = "\xca\x01" // canoto.Tag(25, canoto.Len)
	canoto__SpecFuzzer__RepeatedSfixed64__tag           = "\xd2\x01" // canoto.Tag(26, canoto.Len)
	canoto__SpecFuzzer__RepeatedFixed64__tag            = "\xda\x01" // canoto.Tag(27, canoto.Len)
	canoto__SpecFuzzer__RepeatedBool__tag               = "\xe2\x01" // canoto.Tag(28, canoto.Len)
	canoto__SpecFuzzer__RepeatedString__tag             = "\xea\x01" // canoto.Tag(29, canoto.Len)
	canoto__SpecFuzzer__RepeatedBytes__tag              = "\xf2\x01" // canoto.Tag(30, canoto.Len)
	canoto__SpecFuzzer__RepeatedLargestFieldNumber__tag = "\xfa\x01" // canoto.Tag(31, canoto.Len)
	canoto__SpecFuzzer__OneOf__tag                      = "\x82\x02" // canoto.Tag(32, canoto.Len)
	canoto__SpecFuzzer__Pointer__tag                    = "\x8a\x02" // canoto.Tag(33, canoto.Len)
	canoto__SpecFuzzer__Field__tag                      = "\x92\x02" // canoto.Tag(34, canoto.Len)
	canoto__SpecFuzzer__Recursive__tag                  = "\x9a\x02" // canoto.Tag(35, canoto.Len)
)

type canotoData_SpecFuzzer struct {
	size               uint64
	RepeatedInt8Size   uint64
	RepeatedInt16Size  uint64
	RepeatedInt32Size  uint64
	RepeatedInt64Size  uint64
	RepeatedUint16Size uint64
	RepeatedUint32Size uint64
	RepeatedUint64Size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*SpecFuzzer) CanotoSpec(types ...reflect.Type) *Spec {
	types = append(types, reflect.TypeOf(SpecFuzzer{}))
	var zero SpecFuzzer
	s := &Spec{
		Name: "SpecFuzzer",
		Fields: []FieldType{
			{
				FieldNumber: 1,
				Name:        "Int8",
				OneOf:       "",
				TypeInt:     SizeOf(zero.Int8),
			},
			{
				FieldNumber: 2,
				Name:        "Int16",
				OneOf:       "",
				TypeInt:     SizeOf(zero.Int16),
			},
			{
				FieldNumber: 3,
				Name:        "Int32",
				OneOf:       "",
				TypeInt:     SizeOf(zero.Int32),
			},
			{
				FieldNumber: 4,
				Name:        "Int64",
				OneOf:       "",
				TypeInt:     SizeOf(zero.Int64),
			},
			{
				FieldNumber: 5,
				Name:        "Uint8",
				OneOf:       "",
				TypeUint:    SizeOf(zero.Uint8),
			},
			{
				FieldNumber: 6,
				Name:        "Uint16",
				OneOf:       "",
				TypeUint:    SizeOf(zero.Uint16),
			},
			{
				FieldNumber: 7,
				Name:        "Uint32",
				OneOf:       "",
				TypeUint:    SizeOf(zero.Uint32),
			},
			{
				FieldNumber: 8,
				Name:        "Uint64",
				OneOf:       "",
				TypeUint:    SizeOf(zero.Uint64),
			},
			FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed32,
				/*FieldNumber:   */ 9,
				/*Name:          */ "Sfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			FieldTypeFromFint(
				/*type inference:*/ zero.Fixed32,
				/*FieldNumber:   */ 10,
				/*Name:          */ "Fixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			FieldTypeFromFint(
				/*type inference:*/ zero.Sfixed64,
				/*FieldNumber:   */ 11,
				/*Name:          */ "Sfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			FieldTypeFromFint(
				/*type inference:*/ zero.Fixed64,
				/*FieldNumber:   */ 12,
				/*Name:          */ "Fixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 13,
				Name:        "Bool",
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 14,
				Name:        "String",
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 15,
				Name:        "Bytes",
				OneOf:       "",
				TypeBytes:   true,
			},
			FieldTypeFromField(
				/*type inference:*/ (zero.LargestFieldNumber),
				/*FieldNumber:   */ 16,
				/*Name:          */ "LargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			{
				FieldNumber: 17,
				Name:        "RepeatedInt8",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     SizeOf(MakeEntry(zero.RepeatedInt8)),
			},
			{
				FieldNumber: 18,
				Name:        "RepeatedInt16",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     SizeOf(MakeEntry(zero.RepeatedInt16)),
			},
			{
				FieldNumber: 19,
				Name:        "RepeatedInt32",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     SizeOf(MakeEntry(zero.RepeatedInt32)),
			},
			{
				FieldNumber: 20,
				Name:        "RepeatedInt64",
				Repeated:    true,
				OneOf:       "",
				TypeInt:     SizeOf(MakeEntry(zero.RepeatedInt64)),
			},
			{
				FieldNumber: 21,
				Name:        "RepeatedUint16",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    SizeOf(MakeEntry(zero.RepeatedUint16)),
			},
			{
				FieldNumber: 22,
				Name:        "RepeatedUint32",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    SizeOf(MakeEntry(zero.RepeatedUint32)),
			},
			{
				FieldNumber: 23,
				Name:        "RepeatedUint64",
				Repeated:    true,
				OneOf:       "",
				TypeUint:    SizeOf(MakeEntry(zero.RepeatedUint64)),
			},
			FieldTypeFromFint(
				/*type inference:*/ MakeEntry(zero.RepeatedSfixed32),
				/*FieldNumber:   */ 24,
				/*Name:          */ "RepeatedSfixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			FieldTypeFromFint(
				/*type inference:*/ MakeEntry(zero.RepeatedFixed32),
				/*FieldNumber:   */ 25,
				/*Name:          */ "RepeatedFixed32",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			FieldTypeFromFint(
				/*type inference:*/ MakeEntry(zero.RepeatedSfixed64),
				/*FieldNumber:   */ 26,
				/*Name:          */ "RepeatedSfixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			FieldTypeFromFint(
				/*type inference:*/ MakeEntry(zero.RepeatedFixed64),
				/*FieldNumber:   */ 27,
				/*Name:          */ "RepeatedFixed64",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
			),
			{
				FieldNumber: 28,
				Name:        "RepeatedBool",
				Repeated:    true,
				OneOf:       "",
				TypeBool:    true,
			},
			{
				FieldNumber: 29,
				Name:        "RepeatedString",
				Repeated:    true,
				OneOf:       "",
				TypeString:  true,
			},
			{
				FieldNumber: 30,
				Name:        "RepeatedBytes",
				Repeated:    true,
				OneOf:       "",
				TypeBytes:   true,
			},
			FieldTypeFromField(
				/*type inference:*/ (MakeEntryNilPointer(zero.RepeatedLargestFieldNumber)),
				/*FieldNumber:   */ 31,
				/*Name:          */ "RepeatedLargestFieldNumber",
				/*FixedLength:   */ 0,
				/*Repeated:      */ true,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			FieldTypeFromField(
				/*type inference:*/ (zero.OneOf),
				/*FieldNumber:   */ 32,
				/*Name:          */ "OneOf",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			FieldTypeFromField(
				/*type inference:*/ (zero.Pointer),
				/*FieldNumber:   */ 33,
				/*Name:          */ "Pointer",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			FieldTypeFromField(
				/*type inference:*/ zero.Field,
				/*FieldNumber:   */ 34,
				/*Name:          */ "Field",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
			FieldTypeFromField(
				/*type inference:*/ (zero.Recursive),
				/*FieldNumber:   */ 35,
				/*Name:          */ "Recursive",
				/*FixedLength:   */ 0,
				/*Repeated:      */ false,
				/*OneOf:         */ "",
				/*types:         */ types,
			),
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*SpecFuzzer) MakeCanoto() *SpecFuzzer {
	return new(SpecFuzzer)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *SpecFuzzer) UnmarshalCanoto(bytes []byte) error {
	r := Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *SpecFuzzer) UnmarshalCanotoFrom(r Reader) error {
	// Zero the struct before unmarshaling.
	*c = SpecFuzzer{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for HasNext(&r) {
		field, wireType, err := ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadInt(&r, &c.Int8); err != nil {
				return err
			}
			if IsZero(c.Int8) {
				return ErrZeroValue
			}
		case 2:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadInt(&r, &c.Int16); err != nil {
				return err
			}
			if IsZero(c.Int16) {
				return ErrZeroValue
			}
		case 3:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadInt(&r, &c.Int32); err != nil {
				return err
			}
			if IsZero(c.Int32) {
				return ErrZeroValue
			}
		case 4:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadInt(&r, &c.Int64); err != nil {
				return err
			}
			if IsZero(c.Int64) {
				return ErrZeroValue
			}
		case 5:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadUint(&r, &c.Uint8); err != nil {
				return err
			}
			if IsZero(c.Uint8) {
				return ErrZeroValue
			}
		case 6:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadUint(&r, &c.Uint16); err != nil {
				return err
			}
			if IsZero(c.Uint16) {
				return ErrZeroValue
			}
		case 7:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadUint(&r, &c.Uint32); err != nil {
				return err
			}
			if IsZero(c.Uint32) {
				return ErrZeroValue
			}
		case 8:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadUint(&r, &c.Uint64); err != nil {
				return err
			}
			if IsZero(c.Uint64) {
				return ErrZeroValue
			}
		case 9:
			if wireType != I32 {
				return ErrUnexpectedWireType
			}

			if err := ReadFint32(&r, &c.Sfixed32); err != nil {
				return err
			}
			if IsZero(c.Sfixed32) {
				return ErrZeroValue
			}
		case 10:
			if wireType != I32 {
				return ErrUnexpectedWireType
			}

			if err := ReadFint32(&r, &c.Fixed32); err != nil {
				return err
			}
			if IsZero(c.Fixed32) {
				return ErrZeroValue
			}
		case 11:
			if wireType != I64 {
				return ErrUnexpectedWireType
			}

			if err := ReadFint64(&r, &c.Sfixed64); err != nil {
				return err
			}
			if IsZero(c.Sfixed64) {
				return ErrZeroValue
			}
		case 12:
			if wireType != I64 {
				return ErrUnexpectedWireType
			}

			if err := ReadFint64(&r, &c.Fixed64); err != nil {
				return err
			}
			if IsZero(c.Fixed64) {
				return ErrZeroValue
			}
		case 13:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadBool(&r, &c.Bool); err != nil {
				return err
			}
			if IsZero(c.Bool) {
				return ErrZeroValue
			}
		case 14:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			if err := ReadString(&r, &c.String); err != nil {
				return err
			}
			if len(c.String) == 0 {
				return ErrZeroValue
			}
		case 15:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			if err := ReadBytes(&r, &c.Bytes); err != nil {
				return err
			}
			if len(c.Bytes) == 0 {
				return ErrZeroValue
			}
		case 16:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.LargestFieldNumber = MakePointer(c.LargestFieldNumber)
			if err := (c.LargestFieldNumber).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 17:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt8 = MakeSlice(c.RepeatedInt8, CountInts(msgBytes))
			field := c.RepeatedInt8
			for i := range field {
				if err := ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt8Size, uint64(len(msgBytes)))
		case 18:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt16 = MakeSlice(c.RepeatedInt16, CountInts(msgBytes))
			field := c.RepeatedInt16
			for i := range field {
				if err := ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt16Size, uint64(len(msgBytes)))
		case 19:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt32 = MakeSlice(c.RepeatedInt32, CountInts(msgBytes))
			field := c.RepeatedInt32
			for i := range field {
				if err := ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt32Size, uint64(len(msgBytes)))
		case 20:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedInt64 = MakeSlice(c.RepeatedInt64, CountInts(msgBytes))
			field := c.RepeatedInt64
			for i := range field {
				if err := ReadInt(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedInt64Size, uint64(len(msgBytes)))
		case 21:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint16 = MakeSlice(c.RepeatedUint16, CountInts(msgBytes))
			field := c.RepeatedUint16
			for i := range field {
				if err := ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint16Size, uint64(len(msgBytes)))
		case 22:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint32 = MakeSlice(c.RepeatedUint32, CountInts(msgBytes))
			field := c.RepeatedUint32
			for i := range field {
				if err := ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint32Size, uint64(len(msgBytes)))
		case 23:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedUint64 = MakeSlice(c.RepeatedUint64, CountInts(msgBytes))
			field := c.RepeatedUint64
			for i := range field {
				if err := ReadUint(&r, &field[i]); err != nil {
					return err
				}
			}
			if HasNext(&r) {
				return ErrInvalidLength
			}
			r.B = remainingBytes
			atomic.StoreUint64(&c.canotoData.RepeatedUint64Size, uint64(len(msgBytes)))
		case 24:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return ErrZeroValue
			}
			if numMsgBytes%SizeFint32 != 0 {
				return ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed32 = MakeSlice(c.RepeatedSfixed32, numMsgBytes/SizeFint32)
			field := c.RepeatedSfixed32
			for i := range field {
				if err := ReadFint32(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 25:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return ErrZeroValue
			}
			if numMsgBytes%SizeFint32 != 0 {
				return ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed32 = MakeSlice(c.RepeatedFixed32, numMsgBytes/SizeFint32)
			field := c.RepeatedFixed32
			for i := range field {
				if err := ReadFint32(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 26:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return ErrZeroValue
			}
			if numMsgBytes%SizeFint64 != 0 {
				return ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedSfixed64 = MakeSlice(c.RepeatedSfixed64, numMsgBytes/SizeFint64)
			field := c.RepeatedSfixed64
			for i := range field {
				if err := ReadFint64(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 27:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return ErrZeroValue
			}
			if numMsgBytes%SizeFint64 != 0 {
				return ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedFixed64 = MakeSlice(c.RepeatedFixed64, numMsgBytes/SizeFint64)
			field := c.RepeatedFixed64
			for i := range field {
				if err := ReadFint64(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 28:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the packed field bytes.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Verify the length of the packed field bytes.
			numMsgBytes := uint64(len(msgBytes))
			if numMsgBytes == 0 {
				return ErrZeroValue
			}
			if numMsgBytes%SizeBool != 0 {
				return ErrInvalidLength
			}

			// Read each value from the packed field bytes into the array.
			remainingBytes := r.B
			r.B = msgBytes
			c.RepeatedBool = MakeSlice(c.RepeatedBool, numMsgBytes/SizeBool)
			field := c.RepeatedBool
			for i := range field {
				if err := ReadBool(&r, &field[i]); err != nil {
					return err
				}
			}
			r.B = remainingBytes
		case 29:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := CountBytes(r.B, canoto__SpecFuzzer__RepeatedString__tag)
			if err != nil {
				return err
			}
			c.RepeatedString = MakeSlice(c.RepeatedString, countMinus1+1)
			field := c.RepeatedString

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := ReadString(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__SpecFuzzer__RepeatedString__tag):]
				if err := ReadString(&r, &field[i]); err != nil {
					return err
				}
			}
		case 30:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Skip the first entry because we have already stripped the tag.
			remainingBytes := r.B
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			if err := ReadBytes(&r, new([]byte)); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := CountBytes(r.B, canoto__SpecFuzzer__RepeatedBytes__tag)
			if err != nil {
				return err
			}
			c.RepeatedBytes = MakeSlice(c.RepeatedBytes, countMinus1+1)
			field := c.RepeatedBytes

			// Read the first entry manually because the tag is still already
			// stripped.
			r.B = remainingBytes
			if err := ReadBytes(&r, &field[0]); err != nil {
				return err
			}

			// Read the rest of the entries, stripping the tag each time.
			field = field[1:]
			for i := range field {
				r.B = r.B[len(canoto__SpecFuzzer__RepeatedBytes__tag):]
				if err := ReadBytes(&r, &field[i]); err != nil {
					return err
				}
			}
		case 31:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the first entry manually because the tag is already
			// stripped.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			r.Unsafe = originalUnsafe

			// Count the number of additional entries after the first entry.
			countMinus1, err := CountBytes(r.B, canoto__SpecFuzzer__RepeatedLargestFieldNumber__tag)
			if err != nil {
				return err
			}

			c.RepeatedLargestFieldNumber = MakeSlice(c.RepeatedLargestFieldNumber, countMinus1+1)
			field := c.RepeatedLargestFieldNumber
			additionalField := field[1:]
			if len(msgBytes) != 0 {
				remainingBytes := r.B
				r.B = msgBytes
				if err := (&field[0]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}

			// Read the rest of the entries, stripping the tag each time.
			for i := range additionalField {
				r.B = r.B[len(canoto__SpecFuzzer__RepeatedLargestFieldNumber__tag):]
				r.Unsafe = true
				if err := ReadBytes(&r, &msgBytes); err != nil {
					return err
				}
				if len(msgBytes) == 0 {
					continue
				}
				r.Unsafe = originalUnsafe

				remainingBytes := r.B
				r.B = msgBytes
				if err := (&additionalField[i]).UnmarshalCanotoFrom(r); err != nil {
					return err
				}
				r.B = remainingBytes
			}
		case 32:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.OneOf = MakePointer(c.OneOf)
			if err := (c.OneOf).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 33:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Pointer = MakePointer(c.Pointer)
			if err := (c.Pointer).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 34:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Field = c.Field.MakeCanoto()
			if err := c.Field.UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		case 35:
			if wireType != Len {
				return ErrUnexpectedWireType
			}

			// Read the bytes for the field.
			originalUnsafe := r.Unsafe
			r.Unsafe = true
			var msgBytes []byte
			if err := ReadBytes(&r, &msgBytes); err != nil {
				return err
			}
			if len(msgBytes) == 0 {
				return ErrZeroValue
			}
			r.Unsafe = originalUnsafe

			// Unmarshal the field from the bytes.
			remainingBytes := r.B
			r.B = msgBytes
			c.Recursive = MakePointer(c.Recursive)
			if err := (c.Recursive).UnmarshalCanotoFrom(r); err != nil {
				return err
			}
			r.B = remainingBytes
		default:
			return ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *SpecFuzzer) ValidCanoto() bool {
	if c == nil {
		return true
	}
	if !ValidString(c.String) {
		return false
	}
	if c.LargestFieldNumber != nil && !(c.LargestFieldNumber).ValidCanoto() {
		return false
	}
	for _, v := range c.RepeatedString {
		if !ValidString(v) {
			return false
		}
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			if !(&field[i]).ValidCanoto() {
				return false
			}
		}
	}
	if c.OneOf != nil && !(c.OneOf).ValidCanoto() {
		return false
	}
	if c.Pointer != nil && !(c.Pointer).ValidCanoto() {
		return false
	}
	if !c.Field.ValidCanoto() {
		return false
	}
	if c.Recursive != nil && !(c.Recursive).ValidCanoto() {
		return false
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *SpecFuzzer) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !IsZero(c.Int8) {
		size += uint64(len(canoto__SpecFuzzer__Int8__tag)) + SizeInt(c.Int8)
	}
	if !IsZero(c.Int16) {
		size += uint64(len(canoto__SpecFuzzer__Int16__tag)) + SizeInt(c.Int16)
	}
	if !IsZero(c.Int32) {
		size += uint64(len(canoto__SpecFuzzer__Int32__tag)) + SizeInt(c.Int32)
	}
	if !IsZero(c.Int64) {
		size += uint64(len(canoto__SpecFuzzer__Int64__tag)) + SizeInt(c.Int64)
	}
	if !IsZero(c.Uint8) {
		size += uint64(len(canoto__SpecFuzzer__Uint8__tag)) + SizeUint(c.Uint8)
	}
	if !IsZero(c.Uint16) {
		size += uint64(len(canoto__SpecFuzzer__Uint16__tag)) + SizeUint(c.Uint16)
	}
	if !IsZero(c.Uint32) {
		size += uint64(len(canoto__SpecFuzzer__Uint32__tag)) + SizeUint(c.Uint32)
	}
	if !IsZero(c.Uint64) {
		size += uint64(len(canoto__SpecFuzzer__Uint64__tag)) + SizeUint(c.Uint64)
	}
	if !IsZero(c.Sfixed32) {
		size += uint64(len(canoto__SpecFuzzer__Sfixed32__tag)) + SizeFint32
	}
	if !IsZero(c.Fixed32) {
		size += uint64(len(canoto__SpecFuzzer__Fixed32__tag)) + SizeFint32
	}
	if !IsZero(c.Sfixed64) {
		size += uint64(len(canoto__SpecFuzzer__Sfixed64__tag)) + SizeFint64
	}
	if !IsZero(c.Fixed64) {
		size += uint64(len(canoto__SpecFuzzer__Fixed64__tag)) + SizeFint64
	}
	if !IsZero(c.Bool) {
		size += uint64(len(canoto__SpecFuzzer__Bool__tag)) + SizeBool
	}
	if len(c.String) != 0 {
		size += uint64(len(canoto__SpecFuzzer__String__tag)) + SizeBytes(c.String)
	}
	if len(c.Bytes) != 0 {
		size += uint64(len(canoto__SpecFuzzer__Bytes__tag)) + SizeBytes(c.Bytes)
	}
	if c.LargestFieldNumber != nil {
		(c.LargestFieldNumber).CalculateCanotoCache()
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__SpecFuzzer__LargestFieldNumber__tag)) + SizeUint(fieldSize) + fieldSize
		}
	}
	if len(c.RepeatedInt8) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt8 {
			fieldSize += SizeInt(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedInt8__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt8Size, fieldSize)
	}
	if len(c.RepeatedInt16) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt16 {
			fieldSize += SizeInt(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedInt16__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt16Size, fieldSize)
	}
	if len(c.RepeatedInt32) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt32 {
			fieldSize += SizeInt(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedInt32__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt32Size, fieldSize)
	}
	if len(c.RepeatedInt64) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedInt64 {
			fieldSize += SizeInt(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedInt64__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedInt64Size, fieldSize)
	}
	if len(c.RepeatedUint16) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint16 {
			fieldSize += SizeUint(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedUint16__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint16Size, fieldSize)
	}
	if len(c.RepeatedUint32) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint32 {
			fieldSize += SizeUint(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedUint32__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint32Size, fieldSize)
	}
	if len(c.RepeatedUint64) != 0 {
		var fieldSize uint64
		for _, v := range c.RepeatedUint64 {
			fieldSize += SizeUint(v)
		}
		size += uint64(len(canoto__SpecFuzzer__RepeatedUint64__tag)) + SizeUint(fieldSize) + fieldSize
		atomic.StoreUint64(&c.canotoData.RepeatedUint64Size, fieldSize)
	}
	if num := uint64(len(c.RepeatedSfixed32)); num != 0 {
		fieldSize := num * SizeFint32
		size += uint64(len(canoto__SpecFuzzer__RepeatedSfixed32__tag)) + SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedFixed32)); num != 0 {
		fieldSize := num * SizeFint32
		size += uint64(len(canoto__SpecFuzzer__RepeatedFixed32__tag)) + SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedSfixed64)); num != 0 {
		fieldSize := num * SizeFint64
		size += uint64(len(canoto__SpecFuzzer__RepeatedSfixed64__tag)) + SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedFixed64)); num != 0 {
		fieldSize := num * SizeFint64
		size += uint64(len(canoto__SpecFuzzer__RepeatedFixed64__tag)) + SizeUint(fieldSize) + fieldSize
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		fieldSize := num * SizeBool
		size += uint64(len(canoto__SpecFuzzer__RepeatedBool__tag)) + SizeUint(fieldSize) + fieldSize
	}
	for _, v := range c.RepeatedString {
		size += uint64(len(canoto__SpecFuzzer__RepeatedString__tag)) + SizeBytes(v)
	}
	for _, v := range c.RepeatedBytes {
		size += uint64(len(canoto__SpecFuzzer__RepeatedBytes__tag)) + SizeBytes(v)
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			(&field[i]).CalculateCanotoCache()
			fieldSize := (&field[i]).CachedCanotoSize()
			size += uint64(len(canoto__SpecFuzzer__RepeatedLargestFieldNumber__tag)) + SizeUint(fieldSize) + fieldSize
		}
	}
	if c.OneOf != nil {
		(c.OneOf).CalculateCanotoCache()
		if fieldSize := (c.OneOf).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__SpecFuzzer__OneOf__tag)) + SizeUint(fieldSize) + fieldSize
		}
	}
	if c.Pointer != nil {
		(c.Pointer).CalculateCanotoCache()
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__SpecFuzzer__Pointer__tag)) + SizeUint(fieldSize) + fieldSize
		}
	}
	c.Field.CalculateCanotoCache()
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		size += uint64(len(canoto__SpecFuzzer__Field__tag)) + SizeUint(fieldSize) + fieldSize
	}
	if c.Recursive != nil {
		(c.Recursive).CalculateCanotoCache()
		if fieldSize := (c.Recursive).CachedCanotoSize(); fieldSize != 0 {
			size += uint64(len(canoto__SpecFuzzer__Recursive__tag)) + SizeUint(fieldSize) + fieldSize
		}
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *SpecFuzzer) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *SpecFuzzer) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [Writer] and returns the
// resulting [Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *SpecFuzzer) MarshalCanotoInto(w Writer) Writer {
	if c == nil {
		return w
	}
	if !IsZero(c.Int8) {
		Append(&w, canoto__SpecFuzzer__Int8__tag)
		AppendInt(&w, c.Int8)
	}
	if !IsZero(c.Int16) {
		Append(&w, canoto__SpecFuzzer__Int16__tag)
		AppendInt(&w, c.Int16)
	}
	if !IsZero(c.Int32) {
		Append(&w, canoto__SpecFuzzer__Int32__tag)
		AppendInt(&w, c.Int32)
	}
	if !IsZero(c.Int64) {
		Append(&w, canoto__SpecFuzzer__Int64__tag)
		AppendInt(&w, c.Int64)
	}
	if !IsZero(c.Uint8) {
		Append(&w, canoto__SpecFuzzer__Uint8__tag)
		AppendUint(&w, c.Uint8)
	}
	if !IsZero(c.Uint16) {
		Append(&w, canoto__SpecFuzzer__Uint16__tag)
		AppendUint(&w, c.Uint16)
	}
	if !IsZero(c.Uint32) {
		Append(&w, canoto__SpecFuzzer__Uint32__tag)
		AppendUint(&w, c.Uint32)
	}
	if !IsZero(c.Uint64) {
		Append(&w, canoto__SpecFuzzer__Uint64__tag)
		AppendUint(&w, c.Uint64)
	}
	if !IsZero(c.Sfixed32) {
		Append(&w, canoto__SpecFuzzer__Sfixed32__tag)
		AppendFint32(&w, c.Sfixed32)
	}
	if !IsZero(c.Fixed32) {
		Append(&w, canoto__SpecFuzzer__Fixed32__tag)
		AppendFint32(&w, c.Fixed32)
	}
	if !IsZero(c.Sfixed64) {
		Append(&w, canoto__SpecFuzzer__Sfixed64__tag)
		AppendFint64(&w, c.Sfixed64)
	}
	if !IsZero(c.Fixed64) {
		Append(&w, canoto__SpecFuzzer__Fixed64__tag)
		AppendFint64(&w, c.Fixed64)
	}
	if !IsZero(c.Bool) {
		Append(&w, canoto__SpecFuzzer__Bool__tag)
		AppendBool(&w, true)
	}
	if len(c.String) != 0 {
		Append(&w, canoto__SpecFuzzer__String__tag)
		AppendBytes(&w, c.String)
	}
	if len(c.Bytes) != 0 {
		Append(&w, canoto__SpecFuzzer__Bytes__tag)
		AppendBytes(&w, c.Bytes)
	}
	if c.LargestFieldNumber != nil {
		if fieldSize := (c.LargestFieldNumber).CachedCanotoSize(); fieldSize != 0 {
			Append(&w, canoto__SpecFuzzer__LargestFieldNumber__tag)
			AppendUint(&w, fieldSize)
			w = (c.LargestFieldNumber).MarshalCanotoInto(w)
		}
	}
	if len(c.RepeatedInt8) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedInt8__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt8Size))
		for _, v := range c.RepeatedInt8 {
			AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt16) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedInt16__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt16Size))
		for _, v := range c.RepeatedInt16 {
			AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt32) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedInt32__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt32Size))
		for _, v := range c.RepeatedInt32 {
			AppendInt(&w, v)
		}
	}
	if len(c.RepeatedInt64) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedInt64__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedInt64Size))
		for _, v := range c.RepeatedInt64 {
			AppendInt(&w, v)
		}
	}
	if len(c.RepeatedUint16) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedUint16__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint16Size))
		for _, v := range c.RepeatedUint16 {
			AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint32) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedUint32__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint32Size))
		for _, v := range c.RepeatedUint32 {
			AppendUint(&w, v)
		}
	}
	if len(c.RepeatedUint64) != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedUint64__tag)
		AppendUint(&w, atomic.LoadUint64(&c.canotoData.RepeatedUint64Size))
		for _, v := range c.RepeatedUint64 {
			AppendUint(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedSfixed32)); num != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedSfixed32__tag)
		AppendUint(&w, num*SizeFint32)
		for _, v := range c.RepeatedSfixed32 {
			AppendFint32(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedFixed32)); num != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedFixed32__tag)
		AppendUint(&w, num*SizeFint32)
		for _, v := range c.RepeatedFixed32 {
			AppendFint32(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedSfixed64)); num != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedSfixed64__tag)
		AppendUint(&w, num*SizeFint64)
		for _, v := range c.RepeatedSfixed64 {
			AppendFint64(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedFixed64)); num != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedFixed64__tag)
		AppendUint(&w, num*SizeFint64)
		for _, v := range c.RepeatedFixed64 {
			AppendFint64(&w, v)
		}
	}
	if num := uint64(len(c.RepeatedBool)); num != 0 {
		Append(&w, canoto__SpecFuzzer__RepeatedBool__tag)
		AppendUint(&w, num*SizeBool)
		for _, v := range c.RepeatedBool {
			AppendBool(&w, v)
		}
	}
	for _, v := range c.RepeatedString {
		Append(&w, canoto__SpecFuzzer__RepeatedString__tag)
		AppendBytes(&w, v)
	}
	for _, v := range c.RepeatedBytes {
		Append(&w, canoto__SpecFuzzer__RepeatedBytes__tag)
		AppendBytes(&w, v)
	}
	{
		field := c.RepeatedLargestFieldNumber
		for i := range field {
			Append(&w, canoto__SpecFuzzer__RepeatedLargestFieldNumber__tag)
			AppendUint(&w, (&field[i]).CachedCanotoSize())
			w = (&field[i]).MarshalCanotoInto(w)
		}
	}
	if c.OneOf != nil {
		if fieldSize := (c.OneOf).CachedCanotoSize(); fieldSize != 0 {
			Append(&w, canoto__SpecFuzzer__OneOf__tag)
			AppendUint(&w, fieldSize)
			w = (c.OneOf).MarshalCanotoInto(w)
		}
	}
	if c.Pointer != nil {
		if fieldSize := (c.Pointer).CachedCanotoSize(); fieldSize != 0 {
			Append(&w, canoto__SpecFuzzer__Pointer__tag)
			AppendUint(&w, fieldSize)
			w = (c.Pointer).MarshalCanotoInto(w)
		}
	}
	if fieldSize := c.Field.CachedCanotoSize(); fieldSize != 0 {
		Append(&w, canoto__SpecFuzzer__Field__tag)
		AppendUint(&w, fieldSize)
		w = c.Field.MarshalCanotoInto(w)
	}
	if c.Recursive != nil {
		if fieldSize := (c.Recursive).CachedCanotoSize(); fieldSize != 0 {
			Append(&w, canoto__SpecFuzzer__Recursive__tag)
			AppendUint(&w, fieldSize)
			w = (c.Recursive).MarshalCanotoInto(w)
		}
	}
	return w
}

const (
	canoto__LargestFieldNumber__Uint__tag = "\xf8\xff\xff\xff\x0f" // canoto.Tag(536870911, canoto.Varint)
)

type canotoData_LargestFieldNumber struct {
	size uint64
}

// CanotoSpec returns the specification of this canoto message.
func (*LargestFieldNumber[T1]) CanotoSpec(...reflect.Type) *Spec {
	var zero LargestFieldNumber[T1]
	s := &Spec{
		Name: "LargestFieldNumber",
		Fields: []FieldType{
			{
				FieldNumber: 536870911,
				Name:        "Uint",
				OneOf:       "",
				TypeUint:    SizeOf(zero.Uint),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*LargestFieldNumber[T1]) MakeCanoto() *LargestFieldNumber[T1] {
	return new(LargestFieldNumber[T1])
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *LargestFieldNumber[T1]) UnmarshalCanoto(bytes []byte) error {
	r := Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *LargestFieldNumber[T1]) UnmarshalCanotoFrom(r Reader) error {
	// Zero the struct before unmarshaling.
	*c = LargestFieldNumber[T1]{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for HasNext(&r) {
		field, wireType, err := ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return ErrInvalidFieldOrder
		}

		switch field {
		case 536870911:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadUint(&r, &c.Uint); err != nil {
				return err
			}
			if IsZero(c.Uint) {
				return ErrZeroValue
			}
		default:
			return ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *LargestFieldNumber[T1]) ValidCanoto() bool {
	if c == nil {
		return true
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *LargestFieldNumber[T1]) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	if !IsZero(c.Uint) {
		size += uint64(len(canoto__LargestFieldNumber__Uint__tag)) + SizeUint(c.Uint)
	}
	atomic.StoreUint64(&c.canotoData.size, size)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *LargestFieldNumber[T1]) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *LargestFieldNumber[T1]) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [Writer] and returns the
// resulting [Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *LargestFieldNumber[T1]) MarshalCanotoInto(w Writer) Writer {
	if c == nil {
		return w
	}
	if !IsZero(c.Uint) {
		Append(&w, canoto__LargestFieldNumber__Uint__tag)
		AppendUint(&w, c.Uint)
	}
	return w
}

const (
	canoto__OneOf__A1__tag = "\x08" // canoto.Tag(1, canoto.Varint)
	canoto__OneOf__B1__tag = "\x18" // canoto.Tag(3, canoto.Varint)
	canoto__OneOf__B2__tag = "\x20" // canoto.Tag(4, canoto.Varint)
	canoto__OneOf__C__tag  = "\x28" // canoto.Tag(5, canoto.Varint)
	canoto__OneOf__D__tag  = "\x30" // canoto.Tag(6, canoto.Varint)
	canoto__OneOf__A2__tag = "\x38" // canoto.Tag(7, canoto.Varint)
)

type canotoData_OneOf struct {
	size uint64

	AOneOf uint32
	BOneOf uint32
}

// CanotoSpec returns the specification of this canoto message.
func (*OneOf) CanotoSpec(...reflect.Type) *Spec {
	var zero OneOf
	s := &Spec{
		Name: "OneOf",
		Fields: []FieldType{
			{
				FieldNumber: 1,
				Name:        "A1",
				OneOf:       "A",
				TypeInt:     SizeOf(zero.A1),
			},
			{
				FieldNumber: 3,
				Name:        "B1",
				OneOf:       "B",
				TypeInt:     SizeOf(zero.B1),
			},
			{
				FieldNumber: 4,
				Name:        "B2",
				OneOf:       "B",
				TypeInt:     SizeOf(zero.B2),
			},
			{
				FieldNumber: 5,
				Name:        "C",
				OneOf:       "",
				TypeInt:     SizeOf(zero.C),
			},
			{
				FieldNumber: 6,
				Name:        "D",
				OneOf:       "",
				TypeInt:     SizeOf(zero.D),
			},
			{
				FieldNumber: 7,
				Name:        "A2",
				OneOf:       "A",
				TypeInt:     SizeOf(zero.A2),
			},
		},
	}
	s.CalculateCanotoCache()
	return s
}

// MakeCanoto creates a new empty value.
func (*OneOf) MakeCanoto() *OneOf {
	return new(OneOf)
}

// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the struct.
//
// During parsing, the canoto cache is saved.
func (c *OneOf) UnmarshalCanoto(bytes []byte) error {
	r := Reader{
		B: bytes,
	}
	return c.UnmarshalCanotoFrom(r)
}

// UnmarshalCanotoFrom populates the struct from a [Reader]. Most users
// should just use UnmarshalCanoto.
//
// During parsing, the canoto cache is saved.
//
// This function enables configuration of reader options.
func (c *OneOf) UnmarshalCanotoFrom(r Reader) error {
	// Zero the struct before unmarshaling.
	*c = OneOf{}
	atomic.StoreUint64(&c.canotoData.size, uint64(len(r.B)))

	var minField uint32
	for HasNext(&r) {
		field, wireType, err := ReadTag(&r)
		if err != nil {
			return err
		}
		if field < minField {
			return ErrInvalidFieldOrder
		}

		switch field {
		case 1:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.AOneOf, 1) != 0 {
				return ErrDuplicateOneOf
			}

			if err := ReadInt(&r, &c.A1); err != nil {
				return err
			}
			if IsZero(c.A1) {
				return ErrZeroValue
			}
		case 3:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.BOneOf, 3) != 0 {
				return ErrDuplicateOneOf
			}

			if err := ReadInt(&r, &c.B1); err != nil {
				return err
			}
			if IsZero(c.B1) {
				return ErrZeroValue
			}
		case 4:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.BOneOf, 4) != 0 {
				return ErrDuplicateOneOf
			}

			if err := ReadInt(&r, &c.B2); err != nil {
				return err
			}
			if IsZero(c.B2) {
				return ErrZeroValue
			}
		case 5:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadInt(&r, &c.C); err != nil {
				return err
			}
			if IsZero(c.C) {
				return ErrZeroValue
			}
		case 6:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}

			if err := ReadInt(&r, &c.D); err != nil {
				return err
			}
			if IsZero(c.D) {
				return ErrZeroValue
			}
		case 7:
			if wireType != Varint {
				return ErrUnexpectedWireType
			}
			if atomic.SwapUint32(&c.canotoData.AOneOf, 7) != 0 {
				return ErrDuplicateOneOf
			}

			if err := ReadInt(&r, &c.A2); err != nil {
				return err
			}
			if IsZero(c.A2) {
				return ErrZeroValue
			}
		default:
			return ErrUnknownField
		}

		minField = field + 1
	}
	return nil
}

// ValidCanoto validates that the struct can be correctly marshaled into the
// Canoto format.
//
// Specifically, ValidCanoto ensures:
// 1. All OneOfs are specified at most once.
// 2. All strings are valid utf-8.
// 3. All custom fields are ValidCanoto.
func (c *OneOf) ValidCanoto() bool {
	if c == nil {
		return true
	}
	var AOneOf uint32
	var BOneOf uint32
	if !IsZero(c.A1) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 1
	}
	if !IsZero(c.B1) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 3
	}
	if !IsZero(c.B2) {
		if BOneOf != 0 {
			return false
		}
		BOneOf = 4
	}
	if !IsZero(c.A2) {
		if AOneOf != 0 {
			return false
		}
		AOneOf = 7
	}
	return true
}

// CalculateCanotoCache populates size and OneOf caches based on the current
// values in the struct.
//
// It is not safe to copy this struct concurrently.
func (c *OneOf) CalculateCanotoCache() {
	if c == nil {
		return
	}
	var size uint64
	var AOneOf uint32
	var BOneOf uint32
	if !IsZero(c.A1) {
		size += uint64(len(canoto__OneOf__A1__tag)) + SizeInt(c.A1)
		AOneOf = 1
	}
	if !IsZero(c.B1) {
		size += uint64(len(canoto__OneOf__B1__tag)) + SizeInt(c.B1)
		BOneOf = 3
	}
	if !IsZero(c.B2) {
		size += uint64(len(canoto__OneOf__B2__tag)) + SizeInt(c.B2)
		BOneOf = 4
	}
	if !IsZero(c.C) {
		size += uint64(len(canoto__OneOf__C__tag)) + SizeInt(c.C)
	}
	if !IsZero(c.D) {
		size += uint64(len(canoto__OneOf__D__tag)) + SizeInt(c.D)
	}
	if !IsZero(c.A2) {
		size += uint64(len(canoto__OneOf__A2__tag)) + SizeInt(c.A2)
		AOneOf = 7
	}
	atomic.StoreUint64(&c.canotoData.size, size)
	atomic.StoreUint32(&c.canotoData.AOneOf, AOneOf)
	atomic.StoreUint32(&c.canotoData.BOneOf, BOneOf)
}

// CachedCanotoSize returns the previously calculated size of the Canoto
// representation from CalculateCanotoCache.
//
// If CalculateCanotoCache has not yet been called, it will return 0.
//
// If the struct has been modified since the last call to CalculateCanotoCache,
// the returned size may be incorrect.
func (c *OneOf) CachedCanotoSize() uint64 {
	if c == nil {
		return 0
	}
	return atomic.LoadUint64(&c.canotoData.size)
}

// CachedWhichOneOfA returns the previously calculated field number used
// to represent A.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfA() uint32 {
	return atomic.LoadUint32(&c.canotoData.AOneOf)
}

// CachedWhichOneOfB returns the previously calculated field number used
// to represent B.
//
// This field is cached by UnmarshalCanoto, UnmarshalCanotoFrom, and
// CalculateCanotoCache.
//
// If the field has not yet been cached, it will return 0.
//
// If the struct has been modified since the field was last cached, the returned
// field number may be incorrect.
func (c *OneOf) CachedWhichOneOfB() uint32 {
	return atomic.LoadUint32(&c.canotoData.BOneOf)
}

// MarshalCanoto returns the Canoto representation of this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *OneOf) MarshalCanoto() []byte {
	c.CalculateCanotoCache()
	w := Writer{
		B: make([]byte, 0, c.CachedCanotoSize()),
	}
	w = c.MarshalCanotoInto(w)
	return w.B
}

// MarshalCanotoInto writes the struct into a [Writer] and returns the
// resulting [Writer]. Most users should just use MarshalCanoto.
//
// It is assumed that CalculateCanotoCache has been called since the last
// modification to this struct.
//
// It is assumed that this struct is ValidCanoto.
//
// It is not safe to copy this struct concurrently.
func (c *OneOf) MarshalCanotoInto(w Writer) Writer {
	if c == nil {
		return w
	}
	if !IsZero(c.A1) {
		Append(&w, canoto__OneOf__A1__tag)
		AppendInt(&w, c.A1)
	}
	if !IsZero(c.B1) {
		Append(&w, canoto__OneOf__B1__tag)
		AppendInt(&w, c.B1)
	}
	if !IsZero(c.B2) {
		Append(&w, canoto__OneOf__B2__tag)
		AppendInt(&w, c.B2)
	}
	if !IsZero(c.C) {
		Append(&w, canoto__OneOf__C__tag)
		AppendInt(&w, c.C)
	}
	if !IsZero(c.D) {
		Append(&w, canoto__OneOf__D__tag)
		AppendInt(&w, c.D)
	}
	if !IsZero(c.A2) {
		Append(&w, canoto__OneOf__A2__tag)
		AppendInt(&w, c.A2)
	}
	return w
}
