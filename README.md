# Canoto

Canoto is a serialization format designed to be:
1. Fast
2. Compact
3. Canonical
4. Backwards compatible
5. Read compatible with [Protocol Buffers](https://protobuf.dev/).

## Install

```sh
go install github.com/StephenButtolph/canoto/canoto@latest
```


## Define Messages

Canoto messages are defined as normal golang structs:
```golang
type ExampleStruct0 struct {
	Int32       int32          `canoto:"int,1"`
	Int64       int64          `canoto:"int,2"`
	Uint32      uint32         `canoto:"int,3"`
	Uint64      uint64         `canoto:"int,4"`
	Sint32      int32          `canoto:"sint,5"`
	Sint64      int64          `canoto:"sint,6"`
	Fixed32     uint32         `canoto:"fint,7"`
	Fixed64     uint64         `canoto:"fint,8"`
	Sfixed32    int32          `canoto:"fint,9"`
	Sfixed64    int64          `canoto:"fint,10"`
	Bool        bool           `canoto:"bool,11"`
	String      string         `canoto:"bytes,12"`
	Bytes       []byte         `canoto:"bytes,13"`
	OtherStruct ExampleStruct1 `canoto:"bytes,14"`

	canotoData canotoData_ExampleStruct0
}

type ExampleStruct1 struct {
	Int32 int32 `canoto:"int,536870911"`
}
```

All structs must include a field called `canotoData` that will cache the results of calculating the size of the struct.

The type `canotoData_${structName}` is automatically generated by Canoto.

Canoto implements the following `Message` interface for the struct:

```golang
// Message defines a type that can be a stand-alone Canoto message.
type Message interface {
	Field
	// MarshalCanoto returns the Canoto representation of this message.
	//
	// It is assumed that this message is ValidCanoto.
	MarshalCanoto() []byte
	// UnmarshalCanoto unmarshals a Canoto-encoded byte slice into the message.
	//
	// The message is not cleared before unmarshaling, any fields not present in
	// the bytes will retain their previous values.
	UnmarshalCanoto(bytes []byte) error
}

// Field defines a type that can be included inside of a Canoto message.
type Field interface {
	// MarshalCanotoInto writes the field into a canoto.Writer.
	//
	// It is assumed that CalculateCanotoSize has been called since the last
	// modification to this field.
	//
	// It is assumed that this field is ValidCanoto.
	MarshalCanotoInto(w *Writer)
	// CalculateCanotoSize calculates the size of this field's Canoto
	// representation and caches it.
	CalculateCanotoSize() int
	// CachedCanotoSize returns the previously calculated size of the Canoto
	// representation from CalculateCanotoSize.
	//
	// If CalculateCanotoSize has not yet been called, it will return 0.
	//
	// If the field has been modified since the last call to
	// CalculateCanotoSize, the returned size may be incorrect.
	CachedCanotoSize() int
	// UnmarshalCanotoFrom populates the field from a canoto.Reader.
	//
	// The field is not cleared before unmarshaling, any sub-fields not present
	// in the bytes will retain their previous values.
	UnmarshalCanotoFrom(r *Reader) error
	// ValidCanoto validates that the field can be correctly marshaled into the
	// Canoto format.
	ValidCanoto() bool
}
```

## Generate

In order to generate canoto information for all of the structs in a file, simply run the `canoto` command with one or more files.

```sh
canoto example0.go example1.go
```

The above example will generate `example0.canoto.go` and `example1.canoto.go`.

### go:generate

To automatically generate the `.canoto.go` version of a file, it is recommended to use `go:generate`

Placing

```golang
//go:generate canoto $GOFILE
```

at the top of a file will update the `.canoto.go` version of the file every time `go generate ./...` is run.

## Supported Types

### Single Value

| go type     | canoto type | proto type | wire type |
|-------------|-------------|------------|-----------|
| `int8`      | `int`       | `int32`    | `varint`  |
| `int16`     | `int`       | `int32`    | `varint`  |
| `int32`     | `int`       | `int32`    | `varint`  |
| `int64`     | `int`       | `int64`    | `varint`  |
| `uint8`     | `int`       | `uint32`   | `varint`  |
| `uint16`    | `int`       | `uint32`   | `varint`  |
| `uint32`    | `int`       | `uint32`   | `varint`  |
| `uint64`    | `int`       | `uint64`   | `varint`  |
| `int8`      | `sint`      | `sint32`   | `varint`  |
| `int16`     | `sint`      | `sint32`   | `varint`  |
| `int32`     | `sint`      | `sint32`   | `varint`  |
| `int64`     | `sint`      | `sint64`   | `varint`  |
| `uint32`    | `fint`      | `fixed32`  | `i32`     |
| `uint64`    | `fint`      | `fixed64`  | `i64`     |
| `int32`     | `fint`      | `sfixed32` | `i32`     |
| `int64`     | `fint`      | `sfixed64` | `i64`     |
| `bool`      | `bool`      | `bool`     | `varint`  |
| `string`    | `bytes`     | `string`   | `len`     |
| `[]byte`    | `bytes`     | `bytes`    | `len`     |
| `T Field`   | `bytes`     | `bytes`    | `len`     |
| `T Message` | `bytes`     | `message`  | `len`     |

### Repeated Values

| go type       | canoto type | proto type          | wire type | packed  |
|---------------|-------------|---------------------|-----------|---------|
| `[]int8`      | `int`       | `repeated int32`    | `len`     | `true`  |
| `[]int16`     | `int`       | `repeated int32`    | `len`     | `true`  |
| `[]int32`     | `int`       | `repeated int32`    | `len`     | `true`  |
| `[]int64`     | `int`       | `repeated int64`    | `len`     | `true`  |
| `[]uint8`     | `int`       | `repeated uint32`   | `len`     | `true`  |
| `[]uint16`    | `int`       | `repeated uint32`   | `len`     | `true`  |
| `[]uint32`    | `int`       | `repeated uint32`   | `len`     | `true`  |
| `[]uint64`    | `int`       | `repeated uint64`   | `len`     | `true`  |
| `[]int8`      | `sint`      | `repeated sint32`   | `len`     | `true`  |
| `[]int16`     | `sint`      | `repeated sint32`   | `len`     | `true`  |
| `[]int32`     | `sint`      | `repeated sint32`   | `len`     | `true`  |
| `[]int64`     | `sint`      | `repeated sint64`   | `len`     | `true`  |
| `[]uint32`    | `fint`      | `repeated fixed32`  | `len`     | `true`  |
| `[]uint64`    | `fint`      | `repeated fixed64`  | `len`     | `true`  |
| `[]int32`     | `fint`      | `repeated sfixed32` | `len`     | `true`  |
| `[]int64`     | `fint`      | `repeated sfixed64` | `len`     | `true`  |
| `[]bool`      | `bool`      | `repeated bool`     | `len`     | `true`  |
| `[]string`    | `bytes`     | `repeated string`   | `len`     | `false` |
| `[][]byte`    | `bytes`     | `repeated bytes`    | `len`     | `false` |
| `[]T Field`   | `bytes`     | `repeated bytes`    | `len`     | `false` |
| `[]T Message` | `bytes`     | `repeated message`  | `len`     | `false` |

### Fixed Length Repeated Values

| go type        | canoto type | proto type          | wire type | packed  |
|----------------|-------------|---------------------|-----------|---------|
| `[x]int8`      | `int`       | `repeated int32`    | `len`     | `true`  |
| `[x]int16`     | `int`       | `repeated int32`    | `len`     | `true`  |
| `[x]int32`     | `int`       | `repeated int32`    | `len`     | `true`  |
| `[x]int64`     | `int`       | `repeated int64`    | `len`     | `true`  |
| `[x]uint8`     | `int`       | `repeated uint32`   | `len`     | `true`  |
| `[x]uint16`    | `int`       | `repeated uint32`   | `len`     | `true`  |
| `[x]uint32`    | `int`       | `repeated uint32`   | `len`     | `true`  |
| `[x]uint64`    | `int`       | `repeated uint64`   | `len`     | `true`  |
| `[x]int8`      | `sint`      | `repeated sint32`   | `len`     | `true`  |
| `[x]int16`     | `sint`      | `repeated sint32`   | `len`     | `true`  |
| `[x]int32`     | `sint`      | `repeated sint32`   | `len`     | `true`  |
| `[x]int64`     | `sint`      | `repeated sint64`   | `len`     | `true`  |
| `[x]uint32`    | `fint`      | `repeated fixed32`  | `len`     | `true`  |
| `[x]uint64`    | `fint`      | `repeated fixed64`  | `len`     | `true`  |
| `[x]int32`     | `fint`      | `repeated sfixed32` | `len`     | `true`  |
| `[x]int64`     | `fint`      | `repeated sfixed64` | `len`     | `true`  |
| `[x]bool`      | `bool`      | `repeated bool`     | `len`     | `true`  |
| `[x]string`    | `bytes`     | `repeated string`   | `len`     | `false` |
| `[x][]byte`    | `bytes`     | `repeated bytes`    | `len`     | `false` |
| `[][x]byte`    | `bytes`     | `repeated bytes`    | `len`     | `false` |
| `[x][y]byte`   | `bytes`     | `repeated bytes`    | `len`     | `false` |
| `[x]T Field`   | `bytes`     | `repeated bytes`    | `len`     | `false` |
| `[x]T Message` | `bytes`     | `repeated message`  | `len`     | `false` |

### Non-standard encoding

It is valid to define a `Field` that implements a non-standard format. However, this format should still be canonical and the corresponding Proto file should report opaque bytes.

## Why not Proto?

Proto is a fast, compact, encoding format with extensive language support. However, [Proto is not canonical](https://protobuf.dev/programming-guides/serialization-not-canonical/).

Proto is designed to be forwards-compatible. Almost by definition, a forwards-compatible serialization format can not be canonical. The format of a field can not validated to be canonical if the expected type of the field is not known during decoding.

## Why is being canonical important?

In some cases, non-canonical serialization formats are subtle to work with.

For example, if the hash of the serialized data is important or if the serialized data is cryptographically signed.

In order to ensure that the hash of the serialized data does not change, it is important to carefully avoid re-serializing a message that was previously serialized.

For canonical serialization formats, the hash of the serialized data is guaranteed never to change. Every correct implementation of the format will produce the same hash.

## Why be read compatible with Proto?

By being read compatible with Proto, users of the Canoto format inherit some Proto's cross language support.

If an application only needs to read Canoto messages, but not write them, it can simply treat the Canoto message as a Proto message.

## Is Canoto Fast?

Canoto is typically more performant for both serialization and deserialization than Proto. However, Proto does not typically validate that fields are canonical. If a field is expensive to inspect, it's possible Canoto can be slightly slower.

Canoto is optimized to perform no unnecessary memory allocations, so careful management to ensure messages are stack allocated can significantly improve performance over Proto.

## Is Canoto Forwards Compatible?

No. Canoto chooses to be a canonical serialization format rather than being forwards compatible.
